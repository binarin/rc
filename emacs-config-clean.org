* File header
** Enable lexical bindings
  #+begin_src emacs-lisp
    ;; -*- lexical-binding: t -*-
  #+end_src
** Early load of installed packages autoloads
  #+BEGIN_SRC emacs-lisp
    (package-initialize)
  #+END_SRC

** Customization helpers
   #+BEGIN_SRC emacs-lisp
     (require 'general)
     (require 'dash)
     (require 'f)
   #+END_SRC

   ~general-setq~ will also call triggers on customizable setttings,
   allowing them to be properly changed even after corresponding
   package was loaded:
   #+BEGIN_SRC emacs-lisp
     (fset 'gsetq 'general-setq)
   #+END_SRC
* Appearance
** No toolbars/scrollbars
   #+BEGIN_SRC emacs-lisp
     (when (window-system)
       (toggle-scroll-bar -1)
       (tool-bar-mode -1))
     (menu-bar-mode -1)
   #+END_SRC
** Font
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'default-frame-alist
                  '(font . "Iosevka-22"))
   #+END_SRC
** Theme
   #+begin_src emacs-lisp
     (load-theme 'zenburn t)
     (set-face-attribute 'lazy-highlight nil :background "red")
   #+end_src
** Smart mode line

   #+BEGIN_SRC emacs-lisp
     (require 'smart-mode-line)

     (defconst binarin/mode-line-scale-factor 0.6)

     (defun binarin/advise-sml/fill-width-available (orig-fun)
       (if (display-graphic-p)
           (let ((estimated-total-width (floor (/ (window-width) binarin/mode-line-scale-factor))))
             (cl-letf (((symbol-function 'window-total-width) (lambda () estimated-total-width)))
               (funcall orig-fun)))
         (funcall orig-fun)))

     (advice-add 'sml/fill-width-available :around #'binarin/advise-sml/fill-width-available)

     (gsetq sml/no-confirm-load-theme t)
     (gsetq sml/theme 'powerline)

     (sml/setup)

     (set-face-attribute 'mode-line nil :height binarin/mode-line-scale-factor)
     (set-face-attribute 'mode-line-inactive nil :height binarin/mode-line-scale-factor)
     (set-face-attribute 'sml/folder nil :foreground "#aaaaaa")

     (defface binarin/sml-modes-red '((t :inherit sml/minor-modes :foreground "red")) "")

     (gsetq rm-blacklist
            (format "^ \\(%s\\)$"
                    (mapconcat #'identity
                               '("Projectile.*" "Undo-Tree" "ivy" "ElDoc" "Paredit" "ARev" "wb")
                               "\\|"))
            rm-text-properties
            '(("\\` Ovwrt\\'" 'face 'binarin/sml-modes-red)
              ("\\` Wrap\\'" 'face 'default-face)))


     (rich-minority-mode +1)

 #+END_SRC
** Column numbers in modeline
   #+BEGIN_SRC emacs-lisp
     (column-number-mode 1)
   #+END_SRC
** Long lines handling

   Truncate long lines by default:
   #+BEGIN_SRC emacs-lisp
     (setq-default truncate-lines t)
   #+END_SRC

   Use fringe when ~visual-line-mode~ is in effect:
   #+BEGIN_SRC emacs-lisp
     (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
   #+END_SRC

* Behaviour
** Disable startup screen
   #+BEGIN_SRC emacs-lisp
     (gsetq inhibit-startup-screen t)
   #+END_SRC
** Change "yes or no" to "y or n"
   #+begin_src emacs-lisp
     (fset 'yes-or-no-p 'y-or-n-p)
   #+end_src

** Ctrl-Z map
   #+BEGIN_SRC emacs-lisp
     (defvar ctrl-z-map (make-sparse-keymap))

     (general-define-key "C-z" ctrl-z-map)

     (general-define-key
      :keymaps 'ctrl-z-map
      "C-z" 'suspend-frame
      "C-g" 'keyboard-quit)

   #+END_SRC

** Prevent accidental exit
   Prompt on C-x C-c - no more accidential exits
   #+begin_src emacs-lisp
     (gsetq confirm-kill-emacs #'y-or-n-p
            confirm-kill-processes nil)
   #+end_src
** Keeping a lot of history
   #+BEGIN_SRC emacs-lisp
     (gsetq history-length 1000
	    history-delete-duplicates t
	    savehist-file "~/.emacs.d/savehist-clean"
	    savehist-additional-variables '(savehist-minibuffer-history-variables
					    read-expression-history
					    minibuffer-history
					    file-name-history
					    mark-ring
					    search-ring
					    extended-command-history
					    kill-ring
					    search-ring
					    regexp-search-ring
					    compile-history
					    command-history)
	    recentf-max-saved-items 1000)

     (savehist-mode 1)
     (recentf-mode 1)
   #+END_SRC
** execute-extended-command
   ~amx~ also needs to be installed, it's used for sorting according
   to recently used and persisting. counsel automatically detects
   this. ~amx~ is not used directly with ivy completion because
   ~counsel-M-x~ is a bit prettier, with keybindings shown in
   different font.

   #+BEGIN_SRC emacs-lisp
     (general-define-key "M-x" 'counsel-M-x)
   #+END_SRC

** Completion everywhere
   #+BEGIN_SRC emacs-lisp
     (ivy-mode 1)

     (gsetq ivy-use-virtual-buffers t
            ivy-count-format "(%d/%d) "
            ivy-virtual-abbreviate 'abbreviate)

     (set-face-attribute 'ivy-virtual nil :foreground "red")

     (defun binarin/ivy-switch-buffer-shortener (orig-fun str)
       (let ((result (funcall orig-fun str)))
         (replace-regexp-in-string "^/nix/store/.\\{33\\}" "[NIX]" result)))

     (advice-add 'ivy-switch-buffer-transformer :around #'binarin/ivy-switch-buffer-shortener)

     (general-define-key :keymaps 'ivy-minibuffer-map
                         "C-l" 'ivy-backward-kill-word)
   #+END_SRC
** External shell
   #+BEGIN_SRC emacs-lisp
     (gsetq shell-file-name "/bin/sh") ;; mostly for TRAMP, should work everywhere
   #+END_SRC

** Dired
   #+BEGIN_SRC emacs-lisp
     (general-define-key "C-x C-j" 'dired-jump)
     (add-hook 'dired-mode-hook 'dired-hide-details-mode)
   #+END_SRC
** Undo
   #+BEGIN_SRC emacs-lisp
     (global-undo-tree-mode +1)
   #+END_SRC
** Magit
   #+BEGIN_SRC emacs-lisp
     (general-define-key "C-x g" 'magit-status)
   #+END_SRC
** Saving and backups
   Save backups to one place and don't clutter filesystem with files ending in ~\~~ or ~#~.
   #+BEGIN_SRC emacs-lisp
     (defvar binarin/backups-directory "~/.emacs.d/backups-clean")
     (make-directory binarin/backups-directory t)
     (setq backup-directory-alist `(("." . ,binarin/backups-directory)))

     (defvar binarin/auto-save-directory "~/.emacs.d/auto-save-list-clean/")
     (make-directory binarin/auto-save-directory t)
     (setq auto-save-file-name-transforms `((".*" ,binarin/auto-save-directory t)))
   #+END_SRC

   Never delete backup files and never re-use them (this generates
   ~200 megs per year with my usage patterns), they can help to
   recover from a lot of fuckups like ~git reset --hard~:
   #+BEGIN_SRC emacs-lisp
     (setq version-control t)
     (setq delete-old-versions -1)
   #+END_SRC

   The fact that file is under version control is no reason to exclude
   it from this backup scheme (hello again, ~git reset --hard~):
   #+BEGIN_SRC emacs-lisp
     (setq vc-make-backup-files t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (global-auto-revert-mode +1)
   #+END_SRC

** Mark
   #+BEGIN_SRC emacs-lisp
     (gsetq mark-ring-max 64
	    set-mark-command-repeat-pop t
	    global-mark-ring-max 64)
   #+END_SRC
** Whitespace handling
   #+BEGIN_SRC emacs-lisp
     (general-define-key "M-SPC" 'cycle-spacing)
     (setq-default indent-tabs-mode nil)
     (defun binarin/show-trailing-whitespace ()
       (setq show-trailing-whitespace t))
     (add-hook 'prog-mode-hook #'binarin/show-trailing-whitespace)
     (ws-butler-global-mode +1)
     (gsetq require-final-newline 'ask-me)
   #+END_SRC
** Killing
   #+BEGIN_SRC emacs-lisp
     (gsetq kill-do-not-save-duplicates t
            kill-ring-max 256)
     (general-define-key "M-y" 'helm-show-kill-ring)
   #+END_SRC
** Clipboard
   #+BEGIN_SRC emacs-lisp
     (gsetq save-interprogram-paste-before-kill t)
   #+END_SRC
** Bookmarks
   #+BEGIN_SRC emacs-lisp
     (gsetq bookmark-save-flag 1)
   #+END_SRC
** Narrowing
   #+BEGIN_SRC emacs-lisp
     (put 'narrow-to-region 'disabled nil)
   #+END_SRC
** Line numbers
   #+BEGIN_SRC emacs-lisp
     (gsetq line-number-display-limit-width 1000)
   #+END_SRC
** Search
   #+BEGIN_SRC emacs-lisp
     (gsetq isearch-allow-scroll t
	    search-ring-max 128
	    regexp-search-ring-max 128)
     (general-define-key
      :keymaps 'isearch-mode-map
      "M-s M-s" 'swiper-from-isearch)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (defun binarin/search-words ()
       (interactive)
       (when (use-region-p)
	 (browse-url
	  (concat "https://duckduckgo.com/html/?q="
		  (url-hexify-string (buffer-substring (region-beginning) (region-end)))))))

     (general-define-key "M-s M-w" 'binarin/search-words)
   #+END_SRC

** Automatically make scripts executable
   #+BEGIN_SRC emacs-lisp
     (add-hook 'after-save-hook
	       'executable-make-buffer-file-executable-if-script-p)
   #+END_SRC
** Window handling
   Prefer horizontal splits:
   #+BEGIN_SRC emacs-lisp
     (gsetq split-width-threshold 100)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (winner-mode)
   #+END_SRC
** I18n
*** Russian layout over Programmers Dvorak
    :PROPERTIES:
    :ID:       b04b5557-e261-4073-ac6b-93e62e587ed6
    :END:

    #+begin_src emacs-lisp
      ;; -*- coding: iso-2022-7bit-unix -*-
      (quail-define-package
       "russian-computer-d" "Russian" "RU" nil
       "ЙЦУКЕН Russian computer layout over Programmers Dvorak"
       nil t t t t nil nil nil nil nil t)

      ;;  №% "7 ?5 /3 (1 =9 *0 )2 +4 -6 !8 ;:
      ;;   Й  Ц  У  К  Е  Н  Г  Ш  Щ  З  Х  Ъ
      ;;    Ф  Ы  В  А  П  Р  О  Л  Д  Ж  Э
      ;;     Я  Ч  С  М  И  Т  Ь  Б  Ю  .,

      (quail-define-rules
       ("&" ?№)
       ("[" ?\")
       ("{" ??)
       ("}" ?/)
       ("(" ?()
       ("=" ?=)
       ("*" ?*)
       (")" ?))
       ("+" ?+)
       ("]" ?-)
       ("!" ?!)
       ("#" ?\;)
       ("%" ?%)
       ("7" ?7)
       ("5" ?5)
       ("3" ?3)
       ("1" ?1)
       ("9" ?9)
       ("0" ?0)
       ("2" ?2)
       ("4" ?4)
       ("6" ?6)
       ("8" ?8)
       ("`" ?:)

       ("$" ?ё)
       (";" ?й)
       ("," ?ц)
       ("." ?у)
       ("p" ?к)
       ("y" ?е)
       ("f" ?н)
       ("g" ?г)
       ("c" ?ш)
       ("r" ?щ)
       ("l" ?з)
       ("/" ?х)
       ("@" ?ъ)
       ("a" ?ф)
       ("o" ?ы)
       ("e" ?в)
       ("u" ?а)
       ("i" ?п)
       ("d" ?р)
       ("h" ?о)
       ("t" ?л)
       ("n" ?д)
       ("s" ?ж)
       ("-" ?э)
       ("\\" ?\\)
       ("'" ?я)
       ("q" ?ч)
       ("j" ?с)
       ("k" ?м)
       ("x" ?и)
       ("b" ?т)
       ("m" ?ь)
       ("w" ?б)
       ("v" ?ю)
       ("z" ?.)
       ("~" ?Ё)
       (":" ?Й)
       ("<" ?Ц)
       (">" ?У)
       ("P" ?К)
       ("Y" ?Е)
       ("F" ?Н)
       ("G" ?Г)
       ("C" ?Ш)
       ("R" ?Щ)
       ("L" ?З)
       ("?" ?Х)
       ("^" ?Ъ)
       ("A" ?Ф)
       ("O" ?Ы)
       ("E" ?В)
       ("U" ?А)
       ("I" ?П)
       ("D" ?Р)
       ("H" ?О)
       ("T" ?Л)
       ("N" ?Д)
       ("S" ?Ж)
       ("_" ?Э)
       ("|" ?|)
       ("\"" ?Я)
       ("Q" ?Ч)
       ("J" ?С)
       ("K" ?М)
       ("X" ?И)
       ("B" ?Т)
       ("M" ?Ь)
       ("W" ?Б)
       ("V" ?Ю)
       ("Z" ?,))
    #+end_src

*** Prefer Russian and UTF-8
#+begin_src emacs-lisp
  (set-language-environment "Russian")
  (setq default-input-method "russian-computer-d")
  (prefer-coding-system 'utf-8-unix)
#+end_src

* Programming
** Projects
   #+BEGIN_SRC emacs-lisp
     (projectile-mode +1)

     (gsetq projectile-enable-caching t
            projectile-completion-system 'ivy)

     (general-define-key
      :keymaps 'projectile-mode-map
      "C-c p" 'projectile-command-map)
   #+END_SRC

   For my projects I usually don't want to include submodules in file
   list. And anyway, this is broken for some of the things I work on
   (e.g. it fails on submodules without url).
   #+BEGIN_SRC emacs-lisp
     (gsetq projectile-git-submodule-command nil)
   #+END_SRC

** Vue
   #+BEGIN_SRC emacs-lisp
     (defun binarin/vue-mode-hook ()
       (setq-local mmm-submode-decoration-level 0)
       (lsp-vue-mmm-enable)
       (lsp-ui-flycheck-enable t)
       (flycheck-mode))

     (add-hook 'vue-mode-hook #'binarin/vue-mode-hook)

     (eval-after-load "vue-mode"
       (lambda ()
         (require 'lsp-vue)
         (require 'lsp-ui)))
   #+END_SRC
** Perl
   #+BEGIN_SRC emacs-lisp
     (defalias 'perl-mode 'cperl-mode)
     (gsetq cperl-hairy t
            cperl-indent-level 4
            cperl-indent-parens-as-block t
            cperl-close-paren-offset -4)
     (add-hook 'cperl-mode-hook 'ws-butler-mode)
   #+END_SRC
** Lisp
   #+BEGIN_SRC emacs-lisp
     (add-hook 'emacs-lisp-mode-hook       #'enable-paredit-mode)
     (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
     (add-hook 'ielm-mode-hook             #'enable-paredit-mode)
     (add-hook 'lisp-mode-hook             #'enable-paredit-mode)
     (add-hook 'lisp-interaction-mode-hook #'enable-paredit-mode)
     (add-hook 'scheme-mode-hook           #'enable-paredit-mode)
   #+END_SRC

   Prevent ~paredit~ from replacing standard search-related binding:
   #+BEGIN_SRC emacs-lisp
     (eval-after-load "paredit"
       (lambda ()
	 (general-define-key :keymaps 'paredit-mode-map "M-s" nil)))
   #+END_SRC
** Nix
   #+BEGIN_SRC emacs-lisp
     (gsetq nix-indent-function 'nix-indent-line)
     (add-to-list 'auto-mode-alist '("\\.nix\\'" . nix-mode)) ;; fixed by https://github.com/NixOS/nix-mode/commit/f1973ceb4b89e52eec35829722d0dbdcc39fb2ff, should go away soon
   #+END_SRC
* Org mode
** Todo keywords
   #+BEGIN_SRC emacs-lisp
     (gsetq org-todo-keywords
            '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
              (type "|" "CANCELLED(c@/!)")
              (type "HOLD(h!/!)" "WAIT(w@/!)" "|")))

     (gsetq org-todo-keyword-faces
            '(("TODO" :foreground "red" :weight bold)
              ("NEXT" :foreground "cyan3" :weight bold)
              ("DONE" :foreground "green4" :weight bold)

              ("WAIT" :foreground "orange3" :weight bold)
              ("HOLD" :foreground "orange3" :weight bold)
              ("CANCELLED" :foreground "forest green" :weight bold)))

     (gsetq org-enforce-todo-dependencies t)
     (gsetq org-log-done 'time)

     (gsetq org-log-into-drawer t)
   #+END_SRC
** Tags
   #+BEGIN_SRC emacs-lisp
     (gsetq org-fast-tag-selection-single-key 't)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (gsetq org-tags-exclude-from-inheritance '("PROJ"))

     (defconst binarin/context-tags
       '(("@home" :hotkey ?h :includes ("@comp" "@phone"))
         ("@work" :hotkey ?w :includes ("@comp" "@phone"))
         ("@comp" :hotkey ?c :includes ("@phone"))
         ("@errand" :hotkey ?e :includes ("@phone"))
         ("@phone" :hotkey ?p)))

     (gsetq org-tag-alist `((:startgroup . nil)
                            ,@(mapcar (cl-function (lambda ((tag &key hotkey includes)) (cons tag hotkey))) binarin/context-tags)
                            (:endgroup . nil)
                            (:startgroup . nil)
                            ("WAITING" . ?W)
                            ("HOLD" . ?H)
                            ("CANCELLED" . ?C)
                            (:endgroup . nil)
                            ("no-agenda" . ?N)))

     (gsetq org-todo-state-tags-triggers
            '(("CANCELLED" ("CANCELLED" . t))
              ("WAIT" ("WAITING" . t))
              ("HOLD" ("HOLD" . t))
              ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
              ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
              ("DONE" ("WAITING") ("CANCELLED") ("HOLD"))))

   #+END_SRC
** Outline
   #+BEGIN_SRC emacs-lisp
     (gsetq org-cycle-separator-lines 0)
     (gsetq org-catch-invisible-edits 'error)
   #+END_SRC
** Agenda
   Separate block for functions that absolutely require lexical
   scope. I can't make ~eval-buffer~ to respect this setting in
   org-mode source code editors.
   #+BEGIN_SRC emacs-lisp :lexical yes
     (defun binarin/agenda-sorter-tag-first (tag)
       #'(lambda (a b)
           (let ((ta (member (downcase tag) (get-text-property 1 'tags a)))
                 (tb (member (downcase tag) (get-text-property 1 'tags b))))
             (cond
              ((and ta tb) nil)
              ((not ta) -1)
              (t +1)))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (gsetq org-agenda-files
            (-map #'f-expand
                  (-filter #'f-exists?
                           '("~/org/personal.org"
                             "~/org/contacts.org"
                             "~/org/blog.org"
                             "~/org/refile.org"
                             "~/org/booking.org"
                             "~/org/bcal.org"
                             "~/org/bcal-evts.org"
                             "~/.rc/emacs-config-clean.org"
                             "~/org/ference.org"))))

     (gsetq org-agenda-include-diary nil
            org-agenda-span 'day
            org-agenda-start-on-weekday 1
            org-agenda-window-setup 'current-window
            org-agenda-dim-blocked-tasks nil
            org-agenda-compact-blocks t
            org-agenda-block-separator nil)

     (cl-defun binarin/refile-tasks-custom-agenda ()
       '(tags "REFILE"
              ((org-agenda-overriding-header "Task to Refile")
               (org-tags-match-list-sublevels nil)
               (org-agenda-hide-tags-regexp "REFILE\\|CANCELLED\\|WAITING\\|HOLD"))))

     (cl-defun binarin/todo-filter-other-context (primary)
       (let ((includes (plist-get (cdr (assoc primary binarin/context-tags))
                                  :includes)))
         (string-join
          (mapcar
           (lambda (tag) (concat "-" tag))
           (-difference (mapcar #'car binarin/context-tags)
                        (list* primary includes))))))

     (cl-defun binarin/next-tasks-for-context-agenda (primary includes)
       `(tags-todo ,(concat
                     (binarin/todo-filter-other-context primary)
                     "-CANCELLED-HOLD-WAIT-agenda_hide/!NEXT")
                   ((org-agenda-overriding-header ,(format "Next Tasks for %s (minus %s)" primary (binarin/todo-filter-other-context primary)))
                    (org-agenda-sorting-strategy '(priority-down user-defined-down category-up))
                    (org-agenda-cmp-user-defined ',(binarin/agenda-sorter-tag-first primary))
                    (org-agenda-todo-ignore-scheduled t)
                    (org-agenda-todo-ignore-deadlines t)
                    (org-agenda-todo-ignore-with-date t))))

     (cl-defun binarin/custom-agenda-for-context ((tag &key hotkey includes))
       `(,(concat "l" (char-to-string hotkey))
         ,(concat "Agenda for " tag)
         ((agenda "" nil)
          ,(binarin/refile-tasks-custom-agenda)
          ,(binarin/next-tasks-for-context-agenda tag includes))))

     (gsetq org-agenda-custom-commands
            `((" " "Agenda"
               ((agenda "" nil)
                (tags "REFILE"
                      ((org-agenda-overriding-header "Task to Refile")
                       (org-tags-match-list-sublevels nil)))
                (tags-todo "-CANCELLED-agenda_hide/!NEXT"
                           ((org-agenda-overriding-header "Next Tasks")))))
              ("l" . "Context-based agendas")
              ,@(mapcar #'binarin/custom-agenda-for-context binarin/context-tags)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (defun binarin/shrink-text ()
       (text-scale-increase 0)
       (text-scale-increase -1))

     (add-hook 'org-agenda-mode-hook #'binarin/shrink-text)

     (gsetq org-agenda-tags-column -158
            org-tags-column -124)
   #+END_SRC
** Global keybindings
   #+BEGIN_SRC emacs-lisp
     (general-define-key
      "C-c a" 'org-agenda
      "C-c r" 'org-capture)
   #+END_SRC
** Templates
   #+BEGIN_SRC emacs-lisp
     (eval-after-load "org"
       (lambda ()
	 (add-to-list 'org-structure-template-alist '("m" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))))
   #+END_SRC
** Habits
   #+BEGIN_SRC emacs-lisp
     (require 'org-habit)
     (gsetq org-habit-graph-column 50
            org-habit-preceding-days 35)
   #+END_SRC
** Priorities
   #+BEGIN_SRC emacs-lisp
     (gsetq org-highest-priority ?A
            org-lowest-priority ?D
            org-default-priority ?C)

   #+END_SRC
** Contacts
   #+BEGIN_SRC emacs-lisp
     (require 'org-contacts)
     (gsetq org-contacts-files '("~/org/contacts.org"))
   #+END_SRC
** Appearance
   #+BEGIN_SRC emacs-lisp
     (gsetq org-pretty-entities nil)
     (gsetq org-agenda-dim-blocked-tasks nil)
     (gsetq org-ellipsis " ▾")
     ;; Always highlight the current agenda line
     (add-hook 'org-agenda-mode-hook
               '(lambda () (hl-line-mode 1))
               'append)
   #+END_SRC
** Capture
   #+BEGIN_SRC emacs-lisp
     (setq org-capture-templates
                '(("t" "todo" entry
                   (file "~/org/refile.org")
                   "* %?\n  :PROPERTIES:\n  :ID: %(org-id-new)\n  :END:\n  %u\n  %a"
                   :clock-in t :clock-resume t)
                  ("l" "Link" entry
                   (file "~/org/refile.org")
                   "* TODO %a\n  :PROPERTIES:\n  :ID: %(org-id-new)\n  :END:\n  %U\n\n  %i" :immediate-finish t)))
     (setq org-default-notes-file "~/org/refile.org")
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (require 'org-protocol)
     (autoload 'notifications-notify "notifications")

     (defun binarin/display-notify-after-capture (&rest args)
       (notifications-notify
        :title "Link captured"
        :body (cadar org-stored-links)
        :app-name "emacs"
        :app-icon (expand-file-name "~/.rc/org.svg")
        :timeout 3000
        :urgency 'low))

     (advice-add 'org-protocol-do-capture :after #'binarin/display-notify-after-capture)
   #+END_SRC
** Refile
   #+BEGIN_SRC emacs-lisp
     ; Targets include this file and any file contributing to the agenda - up to 9 levels deep
     (setq org-refile-targets '((org-agenda-files :maxlevel . 9)
                                (nil :maxlevel . 9)))

     ; Use full outline paths for refile targets - we file directly with IDO
     (setq org-refile-use-outline-path 'file)

     ; Targets complete directly with IDO
     (setq org-outline-path-complete-in-steps nil)

     ; Allow refile to create parent tasks with confirmation
     (setq org-refile-allow-creating-parent-nodes 'confirm)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (defun binarin/update-parent-todo-statistics (&rest rest)
       (save-excursion
         (org-update-parent-todo-statistics)))

     (add-hook 'org-after-refile-insert-hook #'binarin/update-parent-todo-statistics)

     (advice-add 'org-refile :after #'binarin/update-parent-todo-statistics)

     (advice-add 'org-archive-subtree :after #'binarin/update-parent-todo-statistics)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (defconst binarin/common-tasks-for-refiling
       '(("personal-next" . "ece10822-11d9-4939-b3e2-2d660c0a29ad")
         ("personal-projects" . "f43d2ba5-e840-4382-85da-ff2bf10ff9de")
         ("personal-scheduled" . "13d7a494-3f80-4ffe-a7b4-bded42335342")
         ("booking-next" . "b24815d0-c63e-4525-8fc2-bd64b7319db9")
         ("booking-scheduled" . "ed90c020-04fc-41e4-af5f-256307111d1a")))

     (defun binarin/refile-to-predefined (name)
       (interactive)
       (aand (assoc name binarin/common-tasks-for-refiling)
             (org-id-find (cdr it) t)
             (let ((pos (save-current-buffer
                          (save-excursion
                            (set-buffer (marker-buffer it))
                            (goto-char (marker-position it))
                            (let* ((heading-comps (org-heading-components))
                                   (heading (nth 4 (org-heading-components))))

                              (list heading (buffer-file-name) nil it))))))
               (if (derived-mode-p 'org-agenda-mode)
                   (org-agenda-refile nil pos)
                   (org-refile nil nil pos)))))

     (defhydra binarin/org-refile-hydra (:exit t :hint nil :color pink)
       "
     ^^Personal                    ^^Booking
     ^^------------------------    ^^-----------------------
     _n_ Next Actions              _b_ Next Actions
     _p_ Projects                  _w_ Scheduled and waiting
     _s_ Scheduled and waiting
     "
       ("n" (binarin/refile-to-predefined "personal-next"))
       ("p" (binarin/refile-to-predefined "personal-projects"))
       ("b" (binarin/refile-to-predefined "booking-next"))
       ("s" (binarin/refile-to-predefined "personal-scheduled"))
       ("w" (binarin/refile-to-predefined "booking-scheduled")))

     (general-define-key "C-z C-w" 'binarin/org-refile-hydra/body)
   #+END_SRC

** Babel
   #+BEGIN_SRC emacs-lisp
     (gsetq org-babel-default-header-args:emacs-lisp '((:lexical . "yes")))
   #+END_SRC
* Test space
