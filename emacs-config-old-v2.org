#+TITLE: binarin's emacs configuration
#+OPTIONS: toc:4
* File header
  :PROPERTIES:
  :ID:       872629ce-4d48-47d4-b276-f7935cd31243
  :END:
** Enable lexical bindings
  #+begin_src emacs-lisp
    ;; -*- lexical-binding: t -*-
  #+end_src

** Load helper modules
  #+begin_src emacs-lisp
    (package-initialize)

    (require 'cl-lib)
    (require 'f)
    (require 's)
    (require 'dash)
    (require 'anaphora)
    (require 'hydra)
    (require 'general)

    ;; general-setq will also call triggers on customizable setttings,
    ;; allowing them to be properly changed even after corresponding
    ;; package was loaded
    (fset 'gsetq 'general-setq)
  #+end_src

** Use separate lisp file for customizations made through UI
   Load it early, so any lisp customizations can override customized values.
  #+begin_src emacs-lisp
    (gsetq custom-file (concat (file-name-directory binarin/primary-emacs-config) "custom.el"))
    (load-file custom-file)
  #+end_src

* Startup
** Hide startup screen

   #+begin_src emacs-lisp
       (gsetq inhibit-startup-screen t)
   #+end_src

** Delay keybindings

   I want my keybindings to be applied late in the initialization
   process, after all keymaps are already created and packages are
   loaded.

   #+BEGIN_SRC emacs-lisp
     (defvar binarin/keybindings nil)
     (defvar binarin/keybindings-applied nil)

     (defun binarin/define-key (&rest args)
       (when binarin/keybindings-applied
	 (apply #'general-define-key args))
       (add-to-list 'binarin/keybindings args))

     (defun binarin/apply-queued-keybindings ()
       (setf binarin/keybindings-applied t)
       (-each binarin/keybindings #'(lambda (args) (apply #'general-define-key args))))
   #+END_SRC

* Appearance
** Fonts
   :PROPERTIES:
   :ID:       26d38fee-8252-4024-b0e8-1466ff4052c9
   :END:

  #+begin_src emacs-lisp
    (setf (alist-get 'font default-frame-alist) "Iosevka-22")

    (defconst binarin/minimal-screen-width 124
      "Iosevka-22 on 1920x1080 screen")
  #+end_src

** Theme
   #+begin_src emacs-lisp
     (require 'zenburn-theme)
   #+end_src
** Set window title
   Full name in window title, will be shown in taskbar.

   #+begin_src emacs-lisp
       (gsetq frame-title-format
             '((:eval (if (buffer-file-name)
                          (abbreviate-file-name (buffer-file-name))
                        "%b"))
               " - "
               invocation-name))
   #+end_src

** Remove visual clutter
   :PROPERTIES:
   :ID:       8ee1f692-db6b-4fac-bb48-edb5910c779b
   :END:

   #+begin_src emacs-lisp
     (awhen (window-system)
       (toggle-scroll-bar -1)
       (tool-bar-mode -1))

     (setf (alist-get 'vertical-scroll-bars default-frame-alist) nil)
   #+end_src
** Tool-tips
   #+BEGIN_SRC emacs-lisp
     (gsetq x-gtk-use-system-tooltips nil)
   #+END_SRC
** smart-mode-line
   #+begin_src emacs-lisp
     (require 'smart-mode-line)
     (require 'smart-mode-line-powerline-theme)

     (setf sml/theme 'powerline)
     (setf rm-blacklist '(" hl-p" " Smrt" " Paredit" " Helm" " SliNav" " yas" " MRev" " ARev" " ElDoc" " Undo-Tree" " ^_^" " FS" " Fly" " EditorConfig" " wb" " ez-esc"))
     (sml/setup)
     ;; sml loves to reset this faces completely, so lets enforce our settings after initializing sml
     (set-face-attribute 'mode-line nil :height 0.6)
     (set-face-attribute 'mode-line-inactive nil :height 0.6)
   #+end_src

** Line and column numbers
   #+begin_src emacs-lisp
     (setq line-number-display-limit-width 2000000) ;; prevent '??' instead of line number for files with moderately long lines
     (line-number-mode t)
     (column-number-mode t)
   #+end_src
* Behavior
** Helm
   :PROPERTIES:
   :ID:       8a6ae7ca-1e23-4820-b260-4ece0d844335
   :END:

   #+begin_src emacs-lisp
     (require 'helm-mode)
     (global-unset-key (kbd "C-x c"))

     ;; (require 'helm-org)
     (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
     (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
     (define-key helm-map (kbd "M-x")  'helm-select-action) ; list actions using C-z

     (when (executable-find "curl")
       (gsetq helm-google-suggest-use-curl-p t))

     (gsetq helm-quick-update                     t ; do not display invisible candidates
	   helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
	   helm-buffers-fuzzy-matching           t ; fuzzy matching buffer names when non--nil
	   helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
	   helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
	   helm-ff-file-name-history-use-recentf t)

     (global-set-key (kbd "M-x") 'helm-M-x)
     (global-set-key (kbd "M-y") 'helm-show-kill-ring)
     (global-set-key (kbd "C-x C-f") 'helm-find-files)
     (global-set-key [f3] 'helm-find-files)

     (helm-mode 1)
   #+end_src

** Ivy
   #+BEGIN_SRC emacs-lisp
     (require 'ivy)

     (binarin/define-key "C-'" 'swiper)

     (binarin/define-key
      :keymaps 'ivy-mode-map
      "C-'" 'ivy-avy)

     (ivy-mode 1)

     ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
     (gsetq ivy-use-virtual-buffers t)
     (gsetq ivy-virtual-abbreviate 'full)

     ;; number of result lines to display
     (gsetq ivy-height 10)

     ;; does not count candidates
     (gsetq ivy-count-format "")

     ;; no regexp by default
     (gsetq ivy-initial-inputs-alist nil)

     ;; configure regexp engine.
     (gsetq ivy-re-builders-alist
	    ;; allow input not in order
	    '((t   . ivy--regex-ignore-order)))
   #+END_SRC
** History
    :PROPERTIES:
    :ID:       9dea8cec-794d-4757-84de-2c166ce10567
    :END:
    #+begin_src emacs-lisp
      (gsetq savehist-additional-variables '(search-ring kill-ring regexp-search-ring)
	     savehist-autosave-interval 60 ;; from default 300
	     history-length t
	     history-delete-duplicates t)
      (savehist-mode t)
    #+end_src

    #+begin_src emacs-lisp
      (gsetq recentf-max-saved-items 2000
	     kill-ring-max 5000
	     undo-limit (* 20 1024 1024)
	     undo-strong-limit (* 40 1024 1024)
	     undo-outer-limit (* 100 1024 1024)
	     mark-ring-max 5000
	     global-mark-ring-max 5000)
    #+end_src

    #+begin_src emacs-lisp
      (save-place-mode t)
    #+end_src

** Dired
   #+BEGIN_SRC emacs-lisp
     (add-hook 'dired-mode-hook 'dired-hide-details-mode)
     (binarin/define-key "C-x C-j" 'dired-jump)
     (gsetq dired-dwim-target t)
     (gsetq dired-listing-switches "-al --group-directories-first")
     (eval-after-load "dired"
       #'(lambda () (require 'dired-x)))
   #+END_SRC
** Truncate lines by default
   #+begin_src emacs-lisp
     (gsetq truncate-lines t)
   #+end_src

** Paredit
   :PROPERTIES:
   :ID:       13fbc9ee-bd2c-441b-8b36-ab2d8e153aa7
   :END:

   #+begin_src emacs-lisp
     (add-hook 'emacs-lisp-mode-hook       (lambda () (paredit-mode +1)))
     (add-hook 'example-mode-hook          (lambda () (paredit-mode +1)))
     (add-hook 'lisp-mode-hook             (lambda () (paredit-mode +1)))
     (add-hook 'scheme-mode-hook           (lambda () (paredit-mode +1)))
     (add-hook 'lisp-interaction-mode-hook (lambda () (paredit-mode +1)))
     (add-hook 'slime-repl-mode-hook       (lambda () (paredit-mode +1)))
   #+end_src

** Projectile
   :PROPERTIES:
   :ID:       a86040e5-291f-4b62-ab76-f6b213a483c8
   :END:
   #+begin_src emacs-lisp
     (require 'projectile)
     (gsetq projectile-mode-line nil
            projectile-enable-caching t)

     (projectile-global-mode)

     (add-to-list 'projectile-project-root-files ".edts")
     (add-to-list 'projectile-project-root-files "erlang.mk")
   #+end_src


   Eshell in projectile root
   #+begin_src emacs-lisp
     (defun binarin/projectile-eshell  ()
       (interactive)
       (let* ((height (/ (window-total-height) 3))
              (default-directory (projectile-project-root))
              (eshell-buffer-name (concat "*eshell: " (abbreviate-file-name default-directory) "*")))
         (split-window-vertically (- height))
         (other-window 1)
         (eshell)))

     (defun eshell/n ()
       (if (window-parent)
           (delete-window)
         (switch-to-buffer (other-buffer))))

     (binarin/define-key "C-!" #'binarin/projectile-eshell)
   #+end_src



** Keybindings
   #+BEGIN_SRC emacs-lisp
     (binarin/define-key
      "<f4>" 'replace-string
      "C-<f4>" 'replace-regexp
      "<f12>" 'magit-status
      "C-<f3>" 'binarin/kill-current-buffer)

     (defun binarin/kill-current-buffer ()
       (interactive)
       (kill-buffer (current-buffer)))
   #+END_SRC
** Browser choice
   #+BEGIN_SRC emacs-lisp
     (gsetq browse-url-browser-function #'browse-url-xdg-open)
   #+END_SRC
** Change "yes or no" to "y or n"
   :PROPERTIES:
   :ID:       28aa80f7-9512-43ac-ba91-c45510d86f2c
   :END:

   #+begin_src emacs-lisp
     (fset 'yes-or-no-p 'y-or-n-p)
   #+end_src


** Whitespace handling
*** Tabs and spaces
    #+BEGIN_SRC emacs-lisp
      (setf indent-tabs-mode nil)
      (setf tab-width 8)
      (setq-default indent-tabs-mode nil)
    #+END_SRC
*** ws-butler
    Trims trailing whitespace, but only on lines that were edited.
    #+begin_src emacs-lisp
      (add-hook 'prog-mode-hook 'ws-butler-mode)
      (add-hook 'text-mode-hook 'ws-butler-mode)
    #+end_src
** Ctrl-Z map
   #+BEGIN_SRC emacs-lisp
     (defvar ctrl-z-map (make-sparse-keymap))

     (general-define-key "C-z" ctrl-z-map)

     (binarin/define-key
      :keymaps 'ctrl-z-map
      "C-z" 'suspend-frame
      "C-g" 'keyboard-quit)
   #+END_SRC
** Prevent accidental exit
   Prompt on C-x C-c - no more accidential exits
   #+begin_src emacs-lisp
     (setf confirm-kill-emacs #'y-or-n-p)
   #+end_src
** Copy/paste
   #+BEGIN_SRC emacs-lisp
     (setf select-enable-primary t)
     (setf select-enable-clipboard t)
     (setf save-interprogram-paste-before-kill t)
     (setf x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
   #+END_SRC
** I18n
*** Prefer Russian and UTF-8
#+begin_src emacs-lisp
  (set-language-environment "Russian")
  (setq default-input-method "russian-computer-d")
  (prefer-coding-system 'utf-8-unix)
#+end_src
** Autosaving

   Save backups to one place and don't clutter filesystem with files ending in ~.
   #+begin_src emacs-lisp
     (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
   #+end_src

   As Sacha Chua put it, "Disk space is cheap. Save lots".
   #+begin_src emacs-lisp
     (setq delete-old-versions -1)
     (setq version-control t)
     (setq vc-make-backup-files t)
     (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
   #+end_src

** File locking

   I don't care about preventing simultaneous edits, it still will be
   detected when saving is made. But disabling it prevents our working
   dirs from being clobbered with lock-files.
   #+begin_src emacs-lisp
     (setf create-lockfiles nil)
   #+end_src

** Automatically make scripts executable
   #+BEGIN_SRC emacs-lisp
     (add-hook 'after-save-hook
               'executable-make-buffer-file-executable-if-script-p)
   #+END_SRC
** Window handling
   #+BEGIN_SRC emacs-lisp
     (winner-mode 1)
   #+END_SRC
** Improved help buffers
   #+BEGIN_SRC emacs-lisp
     (autoload 'helpful-function "helpful")
     (global-set-key (kbd "C-h f") #'helpful-function)
   #+END_SRC

** Version control
   #+BEGIN_SRC emacs-lisp
     (setf vc-follow-symlinks t)
   #+END_SRC
** undo-tree
   #+begin_src emacs-lisp
     (require 'undo-tree)
     (add-hook 'after-init-hook 'global-undo-tree-mode)

     (binarin/define-key
      (general-chord "jk") 'undo-tree-undo
      (general-chord "kj") 'undo-tree-undo
      (general-chord "wm") 'undo-tree-redo
      (general-chord "mw") 'undo-tree-redo)
   #+end_src

** Key chords
#+begin_src emacs-lisp
  (require 'key-chord)
  (key-chord-mode t)
#+end_src
** Spell-checking
   #+BEGIN_SRC emacs-lisp
     (setf ispell-dictionary "en")
     (add-hook 'org-mode-hook 'flyspell-mode)
   #+END_SRC
** Tramp
   #+BEGIN_SRC emacs-lisp
     (defun binarin/shell-command-to-string-remote-advice (orig-fun &rest args)
      (let ((shell-file-name (if (tramp-tramp-file-p default-directory)
                                  "/bin/sh"
                                shell-file-name)))
         (apply orig-fun args)))

     (advice-add 'shell-command-to-string :around #'binarin/shell-command-to-string-remote-advice)

     (setq vc-ignore-dir-regexp
           (format "\\(%s\\)\\|\\(%s\\)"
                   vc-ignore-dir-regexp
                   tramp-file-name-regexp))

   #+END_SRC

* Org
** Blogging
   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load 'ox
       (require 'ox-hugo))

     (setf org-hugo-default-section-directory "post")
   #+END_SRC
** Task classification
   #+BEGIN_SRC emacs-lisp
     (defun bh/find-project-task ()
       "Move point to the parent (project) task if any"
       (save-restriction
         (widen)
         (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
           (while (org-up-heading-safe)
             (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
               (setq parent-task (point))))
           (goto-char parent-task)
           parent-task)))

     (defun bh/is-task-p ()
       "Any task with a todo keyword and no subtask"
       (save-restriction
         (widen)
         (let ((has-subtask)
               (subtree-end (save-excursion (org-end-of-subtree t)))
               (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
           (save-excursion
             (forward-line 1)
             (while (and (not has-subtask)
                         (< (point) subtree-end)
                         (re-search-forward "^\*+ " subtree-end t))
               (when (member (org-get-todo-state) org-todo-keywords-1)
                 (setq has-subtask t))))
           (and is-a-task (not has-subtask)))))

     (defun bh/is-project-p ()
       (member "PROJ" (org-get-tags-at)))

     (defun bh/skip-non-stuck-projects ()
       "Skip trees that are not stuck projects"
       ;; (bh/list-sublevels-for-projects-indented)
       (save-restriction
         (widen)
         (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
           (if (bh/is-project-p)
               (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                      (has-next))
                 (save-excursion
                   (forward-line 1)
                   (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ \\(NEXT\\|WAIT\\) " subtree-end t))
                     (setq has-next t)))
                 (if has-next
                     next-headline
                   nil)) ; a stuck project, has subtasks but no next task
             next-headline))))
   #+END_SRC
** Todo states
   #+begin_src emacs-lisp

     (defun bh/clock-in-to-next (kw)
       "Switch a task from TODO to NEXT when clocking in.
     Skips capture tasks, projects, and subprojects.
     Switch projects and subprojects from NEXT back to TODO"
       (when (not (and (boundp 'org-capture-mode) org-capture-mode))
         (cond
          ((and (member (org-get-todo-state) (list "TODO" "HOLD" "WAIT"))
                (bh/is-task-p))
           "NEXT")
          ((and (member (org-get-todo-state) (list "NEXT"))
                (bh/is-project-p))
           "TODO"))))

     (gsetq org-clock-in-switch-to-state #'bh/clock-in-to-next)
   #+end_src

** Tags
   #+begin_src emacs-lisp
     (gsetq org-tags-exclude-from-inheritance '("PROJ"))


     (setq context-tags
           '(("HOME" . ?h)  ;; home
             ("WORK" . ?w)  ;; office
             ("CITY" . ?y)  ;; on the go
             ("COMP" . ?c)  ;; some place that has trusted computer
             ("PHON" . ?o)  ;; anywhere where I can make phone call
             ))

     (setq context-tag-includes
           '(("HOME" "COMP" "PHON")
             ("WORK" "COMP" "PHON")
             ("CITY" "PHON")
             ("COMP")))

     (setq org-tag-alist `((:startgroup . nil) ;; contexts
                           ,@context-tags
                           (:endgroup . nil)
                           ("AGND" . ?a)
                           ("PROJ" . ?p)
                           ("NEXT" . ?n)
                           ("HABT" . ?b)))
   #+end_src
** Projects
   #+BEGIN_SRC emacs-lisp
     (gsetq org-stuck-projects '("+PROJ/+TODO" ("NEXT" "WAIT") nil nil))
   #+END_SRC
** Appearance
   #+begin_src emacs-lisp
     (gsetq org-pretty-entities nil)
     (gsetq org-agenda-dim-blocked-tasks nil)
     (gsetq org-ellipsis " ▾")
     ;; Always highlight the current agenda line
     (add-hook 'org-agenda-mode-hook
               '(lambda () (hl-line-mode 1))
               'append)


     ;; Show all future entries for repeating tasks
     (setq org-agenda-repeating-timestamp-show-all t)

     ;; Show all agenda dates - even if they are empty
     (setq org-agenda-show-all-dates t)


   #+end_src

   #+begin_src emacs-lisp
     (gsetq org-tags-column (- (length org-ellipsis) binarin/minimal-screen-width)
	   org-agenda-tags-column (- (length org-ellipsis) binarin/minimal-screen-width))
   #+end_src

   #+begin_src emacs-lisp
     (eval-after-load "org-habit"
       (lambda ()
	 (gsetq org-habit-graph-column (- binarin/minimal-screen-width
					  org-habit-preceding-days
					  org-habit-following-days
					  1))))
   #+end_src

** Behaviour
   #+begin_src emacs-lisp
     (gsetq org-reverse-note-order t)
   #+end_src
** Agenda
   :PROPERTIES:
   :ID:       861c6807-6e4d-4ea2-9c61-0fcc52f47337
   :END:
   #+begin_src emacs-lisp
     (binarin/define-key "C-c a" 'org-agenda)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (gsetq org-agenda-include-diary nil
            org-agenda-span 'day
            org-agenda-start-on-weekday 1
            org-agenda-window-setup 'current-window

            org-agenda-hide-tags-regexp "ATTACH"
            org-agenda-compact-blocks t

            org-agenda-todo-ignore-with-date nil
            org-agenda-skip-deadline-if-done t
            org-agenda-skip-scheduled-if-done t
            org-agenda-skip-timestamp-if-done t

            org-deadline-warning-days 30
            org-agenda-window-frame-fractions '(1 . 1)
            org-agenda-restore-windows-after-quit t

            org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2 :narrow 60)
            org-clock-report-include-clocking-task 't

            org-agenda-block-separator nil

            org-agenda-clock-consistency-checks '(:max-duration "4:00"
                                                                :min-duration 0
                                                                :max-gap 0
                                                                :gap-ok-around ("4:00")))
   #+END_SRC


   #+begin_src emacs-lisp
     (defun binarin/agenda-sorter-tag-first (tag)
       #'(lambda (a b)
           (let ((ta (member (downcase tag) (get-text-property 1 'tags a)))
                 (tb (member (downcase tag) (get-text-property 1 'tags b))))
             (cond
              ((and ta tb) nil)
              ((not ta) -1)
              (t +1)))))

     (defvar binarin/org-include-scheduled-todos
       '((org-agenda-todo-ignore-scheduled nil)
         (org-agenda-todo-ignore-deadlines nil)
         (org-agenda-todo-ignore-with-date nil))
       "Items with scheduling information are usually hidden from
     agendas, but sometimes we want to include everything. This list
     will spliced into org-agenda-custom-commands on such occasions.
     ")

     (defvar binarin/project-matcher
       "+PROJ/+TODO")

     (defun binarin/todo-filter-for-context (context)
       "Generates tags-todo filter string for a given context"
       (concat (mapconcat 'identity
                          (list* "-agenda_hide-HOLD-REFILE"
                                 (cl-remove-if (lambda (elt)
                                                 (member elt (or (assoc context context-tag-includes)
                                                                 (list context))))
                                               (mapcar 'car context-tags)))
                          "-")
               "/+NEXT"))

     (gsetq org-agenda-sorting-strategy '((agenda habit-down time-up priority-down category-keep)
                                          (todo todo-state-down priority-down user-defined-down category-keep)
                                          (tags priority-down user-defined-down category-keep)
                                          (search category-keep)))

     (gsetq org-agenda-cmp-user-defined (binarin/agenda-sorter-tag-first "NEXT"))

     (defun binarin/shrink-text ()
       (text-scale-increase 0)
       (text-scale-increase -1))

     (add-hook 'org-agenda-mode-hook #'binarin/shrink-text)

     (defun binarin/context-based-agendas ()
       (loop for (tag . char) in context-tags
             collect (list (concat "l" (char-to-string char))
                           (concat "Agenda and context " tag)
                           `((agenda "" nil)
                             (tags-todo "PROJ+TODO=\"TODO\""
                                        ((org-agenda-overriding-header "Stuck Projects")
                                         (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                                         (org-agenda-sorting-strategy '(category-keep))))
                             (tags "+REFILE"
                                        ((org-agenda-overriding-header "Items to refile")
                                         (org-agenda-sorting-strategy '(category-keep))))
                             (tags-todo ,(binarin/todo-filter-for-context tag)
                                        ((org-agenda-overriding-header ,(concat "Tasks for context: " tag))
                                         (org-agenda-todo-ignore-scheduled t)
                                         (org-agenda-todo-ignore-deadlines t)
                                         (org-agenda-sorting-strategy '(priority-down user-defined-down category-up))
                                         (org-agenda-cmp-user-defined ',(binarin/agenda-sorter-tag-first tag))))
                             (todo "WAIT"
                                   ((org-agenda-overriding-header "All waiting tasks")
                                    (org-agenda-todo-ignore-scheduled t)
                                    (org-agenda-todo-ignore-deadlines t)
                                    (org-agenda-sorting-strategy '(priority-down user-defined-down category-up))
                                    (org-agenda-cmp-user-defined ',(binarin/agenda-sorter-tag-first tag))))))))

     (setq org-agenda-custom-commands
           `(("r" "Refile New Notes and Tasks" tags "LEVEL=1+REFILE" ,binarin/org-include-scheduled-todos)
             ("t" "TODOs" tags-todo "-agenda_hide"
              ((org-agenda-sorting-strategy '(priority-down todo-state-down user-defined-down category-up))))
             ("l" . "Context-based agenda")
             ,@(binarin/context-based-agendas)))

     (setq org-agenda-tags-todo-honor-ignore-options t)
   #+end_src
** Contacts
   #+BEGIN_SRC emacs-lisp
     (require 'org-contacts)
     (gsetq org-contacts-files '("~/org/contacts.org"))

     (defconst binarin/org-contact-field-defaults
       '(("TYPE" . "person")
         ("EMAIL" . "")
         ("PHONE" . "")
         ("BIRTHDAY" . "")
         ("GENDER" . "")))

     (defun binarin/helm-org-contacts-field-insert (field)
       (awhen (assoc field binarin/org-contact-field-defaults)
         (org-set-property field (cdr it))
         (org-back-to-heading)
         (let ((range (org-get-property-block (point) 'force)))
           (org-flag-drawer nil)
           (goto-char (car range))
           (re-search-forward (org-re-property field nil t)))))

     (gsetq helm-source-org-contacts-field
       `((name . "Org-contacts fields")
         (candidates . ,(-map #'car binarin/org-contact-field-defaults))
         (no-matchplugin)
         (nohighlight)
         (action . binarin/helm-org-contacts-field-insert)))

     (defun helm-org-contacts-field ()
       "Select a field for insertion in an org-contacts entry."
       (interactive)
       (helm :sources '(helm-source-org-contacts-field)))
   #+END_SRC
** Refiling
   #+BEGIN_SRC emacs-lisp
     ;; Targets include this file and any file contributing to the agenda - up to 5 levels deep
     (gsetq org-refile-targets
            '((org-agenda-files :maxlevel . 5)
              (nil :maxlevel . 5)))

     ;; Targets start with the file name - allows creating level 1 tasks
     (gsetq org-refile-use-outline-path 'file)

     (defun binarin/update-parent-todo-statistics (&rest rest)
       (save-excursion
         (org-update-parent-todo-statistics)))

     (add-hook 'org-after-refile-insert-hook #'binarin/update-parent-todo-statistics)

     (advice-add 'org-refile :after #'binarin/update-parent-todo-statistics)

     (advice-add 'org-archive-subtree :after #'binarin/update-parent-todo-statistics)

     (defconst binarin/common-tasks-for-refiling
       '(("personal-next" . "ece10822-11d9-4939-b3e2-2d660c0a29ad")
         ("personal-projects" . "f43d2ba5-e840-4382-85da-ff2bf10ff9de")
         ("personal-scheduled" . "13d7a494-3f80-4ffe-a7b4-bded42335342")
         ("booking-next" . "b24815d0-c63e-4525-8fc2-bd64b7319db9")
         ("booking-scheduled" . "ed90c020-04fc-41e4-af5f-256307111d1a")))

     (defun binarin/refile-to-predefined (name)
       (interactive)
       (aand (assoc name binarin/common-tasks-for-refiling)
             (org-id-find (cdr it) t)
             (let ((pos (save-current-buffer
                          (save-excursion
                            (set-buffer (marker-buffer it))
                            (goto-char (marker-position it))
                            (let* ((heading-comps (org-heading-components))
                                   (heading (nth 4 (org-heading-components))))

                              (list heading (buffer-file-name) nil it))))))
               (org-refile nil nil pos))))

     (defhydra binarin/org-refile-hydra (:exit t :hint nil :color pink)
       "
     ^^Personal                    ^^Booking
     ^^------------------------    ^^-----------------------
     _n_ Next Actions              _b_ Next Actions
     _p_ Projects                  _w_ Scheduled and waiting
     _s_ Scheduled and waiting
     "
       ("n" (binarin/refile-to-predefined "personal-next"))
       ("p" (binarin/refile-to-predefined "personal-projects"))
       ("b" (binarin/refile-to-predefined "booking-next"))
       ("s" (binarin/refile-to-predefined "personal-scheduled"))
       ("w" (binarin/refile-to-predefined "booking-scheduled")))

     (binarin/define-key "C-z C-w" 'binarin/org-refile-hydra/body)
   #+END_SRC

** Capture
   :PROPERTIES:
   :ID:       4bc78dad-e5f5-40ba-8d98-c57f4261c7a7
   :END:
   #+begin_src emacs-lisp
     (setq org-default-notes-file "~/org/refile.org")
     (define-key global-map "\C-cr" 'org-capture)

     (defun binarin/hide-drawers-hook ()
       (save-excursion
         (beginning-of-buffer)
         (org-cycle-hide-drawers 'children)))

     (defun binarin/capture-remove-guidance-comment ()
       (save-excursion
         (beginning-of-buffer)
         (delete-matching-lines "^ \*# J:")))

     (add-hook 'org-capture-mode-hook #'binarin/hide-drawers-hook)
     (add-hook 'org-capture-mode-hook #'auto-fill-mode)
     (add-hook 'org-capture-prepare-finalize-hook #'binarin/capture-remove-guidance-comment)

     (setq org-capture-templates
           '(("t" "todo" entry
              (file "~/org/refile.org")
              "* %?\n  :PROPERTIES:\n  :ID: %(org-id-new)\n  :END:\n  %u\n  %a"
              :clock-in t :clock-resume t)
             ("j" "journal" entry
              (file+olp+datetree "~/org/journal.org")
              (file "~/.rc/org-journal-template.org")
              :tree-type week :clock-in t :clock-resume t)
             ("n" "comment on clocked" plain
              (clock)
              "%?")
             ("c" "contact" entry
              (file "~/org/refile.org")
              (file "~/.rc/org-contact-template.org"))
             ("w" "org-protocol" entry
              "* TODO %c\n\n  :PROPERTIES:\n  :ID: %(org-id-new)\n  :END:  %U" :immediate-finish t)
             ("l" "Link" entry
              (file "~/org/refile.org")
              "* TODO %a\n  :PROPERTIES:\n  :ID: %(org-id-new)\n  :END:\n  %U\n\n  %i" :immediate-finish t)))

     (defvar binarin/org-protocol-mundane-link-descriptions
       '(" - binarin@gmail.com - Gmail"
         " - binarin@binarin.ru - Mail"
         " - Booking.com Ltd"
         " - YouTube"
         " - alexey.lebedeff@booking.com - Booking.com Mail"))

     (defun binarin/org-protocol-capture-postprocess ()
       (save-excursion
         (beginning-of-buffer))
       (awhen (s-match "binarin@binarin.ru - Mail\\]\\]" (buffer-string))
         (replace-regexp "https://mail\\.google\\.com/mail/u/[0-9]/" "https://mail.google.com/mail/u/?authuser=binarin@binarin.ru"))
       (awhen (s-match "alexey.lebedeff@booking.com - Booking.com Mail\\]\\]" (buffer-string))
         (replace-regexp "https://mail\\.google\\.com/mail/u/[0-9]/" "https://mail.google.com/mail/u/?authuser=alexey.lebedeff@booking.com"))
       (awhen (re-search-forward (concat (regexp-opt binarin/org-protocol-mundane-link-descriptions t) "]]") nil t)
         (replace-match "]]")))

     (add-hook 'org-capture-prepare-finalize-hook #'binarin/org-protocol-capture-postprocess)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (require 'org-protocol)
     (autoload 'notifications-notify "notifications")

     (defun binarin/display-notify-after-capture (&rest args)
       (notifications-notify
        :title "Link captured"
        :body (cadar org-stored-links)
        :app-name "emacs"
        :app-icon (expand-file-name "~/.rc/org.svg")
        :timeout 3000
        :urgency 'low))

     (advice-add 'org-protocol-do-capture :after #'binarin/display-notify-after-capture)
   #+END_SRC

** Persistence
   Synchronization is performed by external process, so try to be in
   sync with disk.
   #+BEGIN_SRC emacs-lisp
     (run-at-time nil 60 'org-save-all-org-buffers)
     (add-hook 'org-mode-hook (lambda () (auto-revert-mode 1)))
   #+END_SRC
** Habits
   #+BEGIN_SRC emacs-lisp
     (require 'org-habit)
   #+END_SRC
** Clocking
   :PROPERTIES:
   :ID:       677d1432-15de-42c8-8a43-f39549acde65
   :END:
   #+begin_src emacs-lisp

     ;; Resume clocking task on clock-in if the clock is open
     (setf org-clock-in-resume t)


     (setq org-time-stamp-rounding-minutes (quote (1 15)))

     (setq org-columns-default-format "%85ITEM(Task) %8Effort(Effort){:} %8CLOCKSUM")
     (setq org-global-properties (quote (("Effort_ALL" . "0:10 0:30 1:00 2:00 3:00 4:00 5:00 6:00 7:00 8:00"))))

     (defun binarin/clockout-nagger ()
       (call-process "desktop-nagger" nil nil nil))

     (defun binarin/clockout-remove-nagger ()
       (call-process "pkill" nil nil nil "-f" "desktop-nagger"))

     (add-hook 'org-clock-out-hook #'binarin/clockout-nagger)
     (add-hook 'org-clock-in-hook #'binarin/clockout-remove-nagger)
   #+end_src
** Notifications
   #+BEGIN_SRC emacs-lisp
     (require 'appt)

     (defun binarin/refresh-appts ()
       (setq appt-time-msg-list nil)
       (org-agenda-to-appt t))

     ;; Run once, activate and schedule refresh
     (binarin/refresh-appts)
     (appt-activate t)
     (run-at-time "24:01" nil #'binarin/refresh-appts)

     ; Update appt each time agenda opened.
     (add-hook 'org-finalize-agenda-hook #'binarin/refresh-appts)

     (defvar binarin/last-appt-notify-id nil)

     (defun binarin/appt-notify (min-to-app new-time msg)
       (setf binarin/last-appt-notify-id
             (notifications-notify
              :title "Appointment"
              :body (if (listp msg) (string-join msg "\\n") msg)
              :timeout 5000
              :urgency 'normal)))


     ; Setup zenify, we tell appt to use window, and replace default function
     (setf appt-display-format 'window)
     (setf appt-disp-window-function #'binarin/appt-notify)
     (setf appt-message-warning-time 10)


   #+END_SRC

** Templates
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-structure-template-alist '("l"  "#+BEGIN_SRC emacs-lisp\n\n#+END_SRC" "<src lang=\"emacs-lisp\">\n\n</src>"))
   #+END_SRC
** Outline options
   #+BEGIN_SRC emacs-lisp
     (gsetq org-cycle-separator-lines 0
            org-special-ctrl-a/e t
            org-ctrl-k-protect-subtree t
            org-special-ctrl-k t
            org-catch-invisible-edits 'smart)


   #+END_SRC
** Custom sorting

#+begin_src emacs-lisp
  (gsetq org-default-priority 68)


  (defvar binarin/priority-todos-for-sorting '("NEXT" "WAIT"))
  (defun binarin/todo-to-started-first-int ()
    "Default todo order is modified by giving more priority to
  todo's from binarin/priority-todos-for-sorting and entries
  without any todo keywords at all."
    (let* ((props (org-entry-properties))
           (item-todo (cdr (assoc "TODO" props)))
           (item-prio (- (aif (cdr (assoc "PRIORITY" props))
                             (aref it 0)
                           org-default-priority)
                         org-highest-priority))
           (item-tags (cdr (assoc "TAGS" props)))
           (modified-todo-order
            (append binarin/priority-todos-for-sorting
                    (-remove #'(lambda (todo) (member todo binarin/priority-todos-for-sorting)) org-todo-keywords-1)))
           (todo-idx (if item-todo (1+ (-elem-index item-todo modified-todo-order)) 0))
           (prio-range (1+ (- org-default-priority org-highest-priority))))
      (+ (* prio-range todo-idx) item-prio)))

  (defun binarin/org-sort-entries ()
    (interactive)
    (org-sort-entries nil ?f #'binarin/todo-to-started-first-int)
    (org-cycle)
    (org-cycle))
#+end_src

* Programming
** Share source position
   #+BEGIN_SRC emacs-lisp
     (defun binarin/get-git-remote-urls ()
       (with-temp-buffer
         (magit-git-insert "remote" "-v")
         (-remove #'null (-map #'(lambda (a) (nth 1 (s-split "[ \t]+" a))) (s-lines (buffer-string))))))

     (defun binarin/get-head-commit-sha ()
       (with-temp-buffer
         (magit-git-insert "rev-parse" "HEAD")
         (s-trim (buffer-string))))

     (defun binarin/make-gitlab-link (base project)
       (let ((commit-sha (binarin/get-head-commit-sha))
             (filename-relative (car (projectile-make-relative-to-root (list (buffer-file-name)))))
             (line-number (string-to-number (format-mode-line "%l"))))
         (format "https://%s/%s/blob/%s/%s#L%d" base project commit-sha filename-relative line-number)))

     (defun binarin/open-web-link-to-source-code ()
       (interactive)
       (aif (block loop
                (dolist (url (binarin/get-git-remote-urls))
                  (anaphoric-cond
                   ((s-match "\\(gitlab\\.[^:]+\\):\\(.*\\)\\.git" url)
                    (return (binarin/make-gitlab-link (nth 1 it) (nth 2 it)))))))
           (browse-url it)
         (message "Failed to generate a link from that file")))
   #+END_SRC
** Perl
   :PROPERTIES:
   :ID:       b63817ac-b572-4f6f-9796-a9031134b76e
   :END:
    #+begin_src emacs-lisp
      (fset 'perl-mode 'cperl-mode)

      (gsetq cperl-auto-newline t
	     cperl-hairy t
	     cperl-brace-offset 0   
	     cperl-close-paren-offset -4  
	     cperl-continued-brace-offset 0   
	     cperl-continued-statement-offset 4   
	     cperl-extra-newline-before-brace nil 
	     cperl-extra-newline-before-brace-multiline nil 
	     cperl-indent-level 4   
	     cperl-indent-parens-as-block t   
	     cperl-label-offset -4  
	     cperl-merge-trailing-else nil 
	     cperl-tab-always-indent t)

      (add-to-list 'auto-mode-alist '("\\.t$" . perl-mode))

      (defun binarin/cperl-mode-hook ()
	(origami-mode t)
	(hs-minor-mode t)
	(yas-minor-mode t)
	(setf prettify-symbols-alist '(("->" . ?→)
				       (">=" . ?≥)
				       ("<=" . ?≤)
				       ("<>" . ?≠)
				       ("=>" . ?⇒)))
  
	(prettify-symbols-mode t)
	(local-set-key (read-kbd-macro "C-c C-c") 'origami-forward-toggle-node)
	(local-set-key (read-kbd-macro "M-.") 'helm-etags-select)
	(setf tags-file-name (expand-file-name "TAGS" (projectile-project-root))
	      tags-table-list nil))

      (add-hook 'cperl-mode-hook 'binarin/cperl-mode-hook)
   #+end_src

* File footer
** Apply delayed keybindings
   #+BEGIN_SRC emacs-lisp
     (binarin/apply-queued-keybindings)
   #+END_SRC
