* Startup stages
* Personal information
  :PROPERTIES:
  :ID:       04b545bf-52b7-412d-9ce5-80ee4bbe10cf
  :END:
  #+begin_src emacs-lisp
    (setf user-full-name "Alexey Lebedeff"
          user-mail-address "binarin@binarin.ru")
    (setf password-cache-expiry nil)
    (setf password-cache t)
  #+end_src
* Appearance
** Performance tuning

   Greatly improves performance for buffers with very long lines.
   #+BEGIN_SRC emacs-lisp
     (setq-default bidi-display-reordering nil)
   #+END_SRC

** Buffer names
   #+begin_src emacs-lisp
     (require 'uniquify)
     (setq uniquify-buffer-name-style 'forward)
     (setq uniquify-separator "/")
     (setq uniquify-after-kill-buffer-p t)
     (setq uniquify-ignore-buffers-re "^\\*")
   #+end_src

** Highlight parentheses
   :PROPERTIES:
   :ID:       239f7033-5510-42f0-aef9-98d6b35b7647
   :END:
   #+begin_src emacs-lisp
     (require 'highlight-parentheses)
     (defun turn-on-highlight-parentheses-mode ()
       (highlight-parentheses-mode t))
     (define-global-minor-mode global-highlight-parentheses-mode
       highlight-parentheses-mode
       turn-on-highlight-parentheses-mode)
     (global-highlight-parentheses-mode t)
   #+end_src
* Behaviour
** Frame handling
   #+BEGIN_SRC emacs-lisp
     (defun clone-indirect-buffer-other-frame (newname display-flag)
       "Like `clone-indirect-buffer-other-window' but display in another frame."
       (interactive
        (progn
          (if (get major-mode 'no-clone-indirect)
              (error "Cannot indirectly clone a buffer in %s mode" mode-name))
          (list (if current-prefix-arg
                    (read-buffer "Name of indirect buffer: " (current-buffer))) t)))
       (save-window-excursion
         (let ((newbuf (clone-indirect-buffer newname display-flag)))
           (switch-to-buffer-other-frame newbuf))))

     (global-set-key (kbd "C-x 5 c") #'clone-indirect-buffer-other-frame)
   #+END_SRC
** Narrowing
   #+BEGIN_SRC emacs-lisp
     (put 'narrow-to-region 'disabled nil)
   #+END_SRC
** Eshell
   :PROPERTIES:
   :ID:       712d9d5a-4541-43ba-b73a-963b86cd511c
   :END:
   #+BEGIN_SRC emacs-lisp
     (eval-after-load "tramp"
       (lambda ()
         (add-hook 'eshell-mode-hook
                   'tramp-eshell-directory-change)))

     (eval-after-load "esh-module"
       (lambda ()
         (add-to-list 'eshell-modules-list 'eshell-tramp)))
   #+END_SRC
** Dired
** Finding configuration pieces from optional directories
   #+begin_src emacs-lisp
     (defvar binarin/optional-config-repos-dir (expand-file-name "~/.rc.d/"))
     (defvar binarin/optional-config-repos (-map #'file-name-as-directory (directory-files binarin/optional-config-repos-dir t "^[0-9a-zA-Z]")))

     (defun binarin/optional-repo-files (filename)
       (loop for dir in binarin/optional-config-repos
             for fullname = (concat dir filename)
             when (file-exists-p fullname)
             collect fullname))
   #+end_src

** Search for authinfo files
   #+begin_src emacs-lisp
     (setf auth-sources (cons
                         "~/.authinfo"
                         (binarin/optional-repo-files ".authinfo.gpg")))
   #+end_src
** Killing buffers and exiting emacs
   :PROPERTIES:
   :ID:       4c9e3061-cfc7-420d-b82c-b8956b8fe95a
   :END:

   Don't kill scratch buffers
   #+BEGIN_SRC emacs-lisp
     (defun binarin/dont-kill-scratch-buffer ()
       (or (not (string= (buffer-name) "*scratch*"))
           (ignore (bury-buffer))))
     (add-hook 'kill-buffer-query-functions #'binarin/dont-kill-scratch-buffer)
   #+END_SRC

** Scrolling
   :PROPERTIES:
   :ID:       6ea7fb69-4f49-4fc6-b8cf-38fe4926b19e
   :END:

   Don't recenter point on redisplay, scroll just enough text to bring
   point into view, even if you move far away.

   #+begin_src emacs-lisp
   (setq scroll-conservatively 101)
   #+end_src

** Yasnippet
   :PROPERTIES:
   :ID:       8db682fa-6f3f-4726-bb46-7b577e9919e4
   :END:
   #+begin_src emacs-lisp
     (require 'yasnippet)
     (setf yas-snippet-dirs '("~/.rc/snippets" yas-installed-snippets-dir))
     (yas-global-mode 1)
   #+end_src

** Viewing PDF inside emacs
   #+BEGIN_SRC emacs-lisp
     (add-hook 'after-init-hook 'pdf-tools-install)
   #+END_SRC
** Other window scrolling
   Scroll PDF by page in other window.

   #+BEGIN_SRC emacs-lisp
     (defun binarin/scroll-other-window (&optional arg)
       (interactive "P")
       (awhen (ignore-errors (other-window-for-scrolling))
         (let* ((buffer (window-buffer it))
                (mode (with-current-buffer buffer major-mode)))
           (cond
            ((eq mode 'pdf-view-mode)
             (save-selected-window
               (select-window it)
               (with-current-buffer buffer
                 (pdf-view-next-page (cond ((eq arg '-) -1)
                                           ((numberp arg) arg)
                                           (t 1))))))
            (t (scroll-other-window arg))))))

     (global-set-key (kbd "C-M-v") #'binarin/scroll-other-window)
   #+END_SRC

** Using settings from .editorconfig
   #+BEGIN_SRC emacs-lisp
     (require 'editorconfig)
     (add-hook 'prog-mode-hook #'(lambda () (editorconfig-mode 1)))
     (add-hook 'text-mode-hook #'(lambda () (editorconfig-mode 1)))
   #+END_SRC
** Completion
   #+BEGIN_SRC emacs-lisp
     ;; (global-company-mode t)
     (eval-after-load "company"
       (lambda ()
         (define-key company-active-map (kbd "C-n") 'company-select-next-or-abort)
         (define-key company-active-map (kbd "C-p") 'company-select-previous-or-abort)))
   #+END_SRC

* Org (to clean up)
** Hacks
   #+BEGIN_SRC emacs-lisp
     (defun binarin/org-reveal-tags ()
       (outline-flag-region (point) (line-end-position) nil))

     (add-hook 'org-after-tags-change-hook #'binarin/org-reveal-tags)
   #+END_SRC

** Agendas
** Projects
   #+begin_src emacs-lisp
     (setf org-stuck-projects
           `(,binarin/project-matcher ("WAITING") ("NEXT") ""))
   #+end_src
** Export
   #+BEGIN_SRC emacs-lisp
     (eval-after-load "ox" (lambda () (require 'htmlize)))
   #+END_SRC
** Mobile sync
    Don't sync with mobile calendars that were downloaded from Google.

    #+begin_src emacs-lisp
      (setf org-mobile-files (-filter #'(lambda (file) (not (s-suffix? "-cal.org" file))) org-agenda-files))
    #+end_src

    #+begin_src emacs-lisp
      (setf org-mobile-inbox-for-pull "~/org/refile.org")
      (setq org-mobile-directory (expand-file-name "~/Dropbox/org/"))
    #+end_src

* Communication
** Email
*** Load custom-built mu4e
    #+begin_src emacs-lisp
      (add-to-list 'load-path "/run/current-system/sw/share/emacs/site-lisp/mu4e")
      (add-to-list 'load-path "~/apps/mu/share/emacs/site-lisp/mu4e")
      (autoload 'mu4e "mu4e" nil t)

      (setf mu4e-mu-binary "/run/current-system/sw/bin/mu")
    #+end_src

*** Unread count extension

    #+begin_src emacs-lisp
      (eval-after-load "mu4e"
        #'(lambda ()
            (require 'mu4e-maildirs-extension)
            (mu4e-maildirs-extension)
            (define-key mu4e-main-mode-map "n" #'next-line)
            (define-key mu4e-main-mode-map "p" #'previous-line)
            (setf mu4e-maildirs-extension-count-command-format
                  (replace-regexp-in-string "^mu" mu4e-mu-binary mu4e-maildirs-extension-count-command-format))

            (setf mu4e-maildirs-extension-custom-list (-remove #'(lambda (x) (or (s-contains? "[Gmail]" x)
                                                                                 (s-contains? "archive-" x)
                                                                                 (s-contains? "Trash" x))) (mu4e-get-maildirs)))
            (setf mu4e-maildirs-extension-insert-before-str "\n  Basics")))


    #+end_src

*** Multiple mail accounts
    #+begin_src emacs-lisp
      (defvar binarin/gmail-accounts '("binarin@gmail.com" "binarin@binarin.ru" "alexey.lebedeff@booking.com"))

      (setf mu4e-user-mail-address-list binarin/gmail-accounts
            mu4e-context-policy 'pick-first)

      (defun binarin/gmail-maildir (email dir)
        (concat "/" email "/" dir))

      (defun binarin/gmail-archive-dir (email folder)
        "\"archive-\" is prefix because of way mu handles wildcards
        like \"/dir/\*\", which is actually interpreted as \"/dir*\""
        (concat "/archive-" email "/" folder))

      (setf message-send-mail-function 'smtpmail-send-it
            smtpmail-default-smtp-server "smtp.gmail.com"
            smtpmail-smtp-server "smtp.gmail.com"
            smtpmail-smtp-service 465
            smtpmail-stream-type 'ssl)

      (defun binarin/make-maildir-mu4e-context (account)
        (make-mu4e-context
         :name account
         :match-func #'(lambda (msg)
                         (when msg
                           (s-equals? account (binarin/mu4e-maildir-to-account
                                               (mu4e-message-field msg :maildir)))))
         :vars `((mail-reply-to . ,account)
                 (user-mail-address . ,account)
                 (smtpmail-smtp-user . ,account))))

      (defun binarin/make-mu4e-contexts ()
        (-map 'binarin/make-maildir-mu4e-context binarin/gmail-accounts))

      (eval-after-load "mu4e" '(setf mu4e-contexts (binarin/make-mu4e-contexts)))

      (defun binarin/mu4e-maildir-to-account (maildir)
        (caddr (s-match "^/\\(archive-\\)?\\([^/]+?\\)/" maildir)))

      (defun binarin/mu4e-sibling-folder (maybe-maildir folder)
        (let ((account (if maybe-maildir
                           (binarin/mu4e-maildir-to-account maybe-maildir)
                         (mu4e-context-name mu4e~context-current))))
          (binarin/gmail-maildir account folder)))

      (defun binarin/mu4e-drafts-folder (maybe-maildir)
        )

      (defun binarin/mu4e-sibling-archive-folder (maildir folder)
        (binarin/gmail-archive-dir (binarin/mu4e-maildir-to-account maildir) folder))



      (setf mu4e-maildir       "~/.mail/"
            mu4e-refile-folder #'(lambda (msg) (binarin/mu4e-sibling-archive-folder (mu4e-message-field msg :maildir) "Archive"))
            mu4e-sent-folder   #'(lambda (msg) (binarin/mu4e-sibling-folder (mu4e-message-field msg :maildir) "Sent"))
            mu4e-drafts-folder #'(lambda (msg) (binarin/mu4e-sibling-folder (and msg (mu4e-message-field msg :maildir)) "Drafts"))
            mu4e-trash-folder  #'(lambda (msg) (binarin/mu4e-sibling-archive-folder (mu4e-message-field msg :maildir) "Trash")))

    #+end_src

*** Appearance
    :PROPERTIES:
    :ID:       b6fdc1ae-0a67-4812-9de0-d36cf22f45fe
    :END:

#+begin_src emacs-lisp
  (autoload 'mu4e-shr2text "mu4e-contrib")
  (setq mu4e-html2text-command 'mu4e-shr2text)

  (defun binarin/mu4e-view-mode-hook ()
    (yas-minor-mode nil)
    (setf fill-column 80)
    (visual-line-mode t)
    ;; (visual-fill-column-mode t)
    )

  (add-hook 'mu4e-view-mode-hook #'binarin/mu4e-view-mode-hook)

  (setq mu4e-view-show-images t)

  (setq mu4e-headers-show-threads t)

  ;; use 'fancy' non-ascii characters in various places in mu4e
  (setq mu4e-use-fancy-chars nil)

  (setf mu4e-headers-fields '((:human-date . 12)
                              (:flags . 6)
                              (:mailing-list . 10)
                              (:from . 22)
                              (:thread-subject)))
#+end_src

*** Behaviour
    :PROPERTIES:
    :ID:       2721952e-54d4-423b-8b65-cbb580f4f2d4
    :END:

    mu4e regenerates main buffer on exiting headers view. But it's annoying when main buffer also
    contains mu4e-maildirs-extension output, because position is lost and it's inconvinient for
    reading unread mailboxes sequentially.
    #+begin_src emacs-lisp
      (defun binarin/mu4e~headers-quit-buffer--non-destructive ()
        (interactive)
        (aif (get-buffer mu4e~main-buffer-name)
            (cl-letf (((symbol-function 'mu4e~main-view) (lambda () nil)))
              (mu4e~headers-quit-buffer)
              (switch-to-buffer it))
            (mu4e~headers-quit-buffer)))

      (eval-after-load "mu4e"
        #'(lambda () (define-key mu4e-headers-mode-map (kbd "q") #'binarin/mu4e~headers-quit-buffer--non-destructive)))
    #+end_src

    Sync mail in background after exiting mu4e
    #+begin_src emacs-lisp
      (defun binarin/mu4e-quit ()
        (interactive)
        (mu4e-update-mail-and-index t)
        (mu4e-quit))

      (eval-after-load "mu4e"
        '(define-key mu4e-main-mode-map "q" #'binarin/mu4e-quit))
    #+end_src


    This is needed for mbsync compatibility:
    #+begin_src emacs-lisp
      (setf mu4e-change-filenames-when-moving t)
    #+end_src

    Don't save messages to Sent Messages, Gmail/IMAP takes care of this.
    #+begin_src emacs-lisp
      (setq mu4e-sent-messages-behavior 'delete)
    #+end_src

    Use helm for completion
    #+begin_src emacs-lisp
      (defun binarin/mu4e-read-option (prompt options)
        (helm-comp-read prompt (-map (lambda (option)
                                       (cons (replace-regexp-in-string "^\\(.\\)" "[\\1]" (car option))
                                             (cdr option)))
                                     options)
                        ;; :sort #'(lambda (a b)
                        ;;           (string-lessp (car a) (car b)))
                        ))

      (eval-after-load "mu4e" '(fset 'mu4e-read-option 'binarin/mu4e-read-option))
    #+end_src

    Mark messages as read while refiling
    #+begin_src emacs-lisp
      (eval-after-load "mu4e"
        #'(lambda ()
            (setf (cdr (assoc 'refile mu4e-marks))
                  '(:char ("r" . "▶")
                          :prompt "refile"
                          :dyn-target (lambda (target msg) (mu4e-get-refile-folder msg))
                          :action (lambda (docid msg target)
                                    (mu4e~proc-move docid (mu4e~mark-check-target target) "+S-u-N"))))))
    #+end_src

    #+begin_src emacs-lisp
      ;; save attachment to my desktop (this can also be a function)
        (setq mu4e-attachment-dir "~/Downloads")

      (setf mu4e-hide-index-messages t)
      (setf mu4e-get-mail-command "true")
      (setf mu4e-confirm-quit nil
            mu4e-headers-leave-behavior 'apply)

      (defun binarin/lazy-load-org-mu4e ()
        (autoload 'org-mu4e-open "org-mu4e")
        (autoload 'org-mu4e-store-link "org-mu4e")
        (org-link-set-parameters "mu4e"
                                 :follow #'org-mu4e-open
                                 :store #'org-mu4e-store-link))

      (eval-after-load "org" '(when (fboundp 'mu4e) (binarin/lazy-load-org-mu4e)))

      ;; (defhydra binarin/mu4e-hydra (:exit t :color red)
      ;;   "Some useful mu4e bookmarks"
      ;;   ("i" (progn (mu4e-update-mail-and-index nil) (mu4e-headers-search "maildir:/INBOX")) "INBOX")
      ;;   ("u" (progn (mu4e-update-mail-and-index nil) (mu4e-headers-search "flag:unread AND NOT maildir:/Trash and NOT maildir:/Lists.Yandex.bbs and NOT maildir:/Yandex.bike")) "Unread work messages")
      ;;   ("f" (progn (mu4e-update-mail-and-index nil) (mu4e-headers-search "flag:unread AND NOT maildir:/Trash and NOT maildir:/Yandex.direct-dev and NOT maildir:/Yandex.direct-review and NOT maildir:/Yandex.perl-dev and NOT maildir:/Yandex.redrose-announces and NOT maildir:/Yandex.staff and NOT maildir:/INBOX")) "Unread fun messages"))


      ;; (global-set-key (kbd "<f9>") #'binarin/mu4e-hydra/body)
    #+end_src

** IRC
   #+begin_src emacs-lisp
     (defun binarin/get-bitlbee-password ()
       (awhen (auth-source-search :host "bitlbee" :max 1)
         (funcall (plist-get (car it) :secret))))

     (setf circe-network-options `(("Freenode"
                                    :channels ("#erlang" "#erlounge" "#rabbitmq" "#nixos" "#haskell" "#reflex-frp"))
                                   ("my bitlbee"
                                    :pass ,(binarin/get-bitlbee-password)
                                    :nick "binarin"
                                    :realname "Alexey Lebedeff"
                                    :channels ("#spdata" "#live" "#hackers")
                                    :nickserv-mask "\\(bitlbee\\|root\\)!\\(bitlbee\\|root\\)@"
                                    :nickserv-identify-challenge "use the \x02identify\x02 command to identify yourself"
                                    :nickserv-identify-command "PRIVMSG &bitlbee :identify {password}"
                                    :nickserv-identify-confirmation "Password accepted, settings and accounts loaded"
                                    :nickserv-nick "binarin"
                                    :nickserv-password ,(binarin/get-bitlbee-password)
                                    :host "127.0.0.1"
                                    :port 6667)))

     (setf circe-reduce-lurker-spam t)

     (eval-after-load "circe"
       (lambda ()
         (require 'circe-color-nicks)
         (enable-circe-color-nicks)
         (load "lui-logging" nil t)
         (enable-lui-logging-globally)))

         (global-set-key (kbd "<f8>") #'tracking-next-buffer)

     (defun irc ()
       (interactive)
       (circe "Freenode")
       (circe "my bitlbee"))


     (defun binarin/circe-chat-mode-hook ()
       (emojify-mode)
       (lui-set-prompt
        (concat (propertize (concat (buffer-name) ">")
        'face 'circe-prompt-face)
                " ")))

     (add-hook 'circe-chat-mode-hook #'binarin/circe-chat-mode-hook)

     (setq lui-flyspell-p t
           lui-flyspell-alist '((".*" "american")))

     (setq
      lui-time-stamp-position 'right-margin
      lui-time-stamp-format "%H:%M")

     (add-hook 'lui-mode-hook 'my-circe-set-margin)
     (defun my-circe-set-margin ()
       (setq right-margin-width 5))

   #+end_src

** Jabber
* Programming
** helm-dash for documentation
   #+BEGIN_SRC emacs-lisp
     (defun binarin/helm-dash-browse-url (url &optional session)
       (other-window 1)
       (xwidget-browse-url-no-reuse url))

     (setf helm-dash-browser-func #'binarin/helm-dash-browse-url)
   #+END_SRC
** Tags
   #+BEGIN_SRC emacs-lisp
     (setf tags-revert-without-query t)
   #+END_SRC
** Elixir
   #+BEGIN_SRC emacs-lisp
     (add-hook 'elixir-mode-hook 'alchemist-mode)
     (add-hook 'elixir-mode-hook 'company-mode)
   #+END_SRC
** Elm
   #+BEGIN_SRC emacs-lisp
     (defun binarin/elm-mode-hook ()
       (company-mode-on))

     (add-hook 'elm-mode-hook #'binarin/elm-mode-hook)

     (eval-after-load "elm-mode"
       (lambda ()
         (require 'company)
         (add-to-list 'company-backends 'company-elm)))
   #+END_SRC
** Erlang
   :PROPERTIES:
   :ID:       f947b108-a5c9-4806-85fc-90592ca8f19a
   :ARCHIVE_TIME: 2016-06-18 Сб 22:49
   :ARCHIVE_FILE: ~/.rc/emacs-config.org
   :ARCHIVE_OLPATH: Programming
   :ARCHIVE_CATEGORY: emacs-config
   :END:

   #+begin_src emacs-lisp
     (defun binarin/erlang-mode-hook ()
       (local-set-key (kbd "M-*") #'edts-find-source-unwind))

     ;; (add-hook 'erlang-mode-hook 'binarin/erlang-mode-hook)

     ;; (when (f-dir? "~/personal-workspace/edts")
     ;;   (setf edts-inhibit-package-check t)
     ;;   (add-to-list 'load-path "~/personal-workspace/edts")
     ;;   (require 'edts-start))
   #+end_src

** Emacs Lisp
   #+BEGIN_SRC emacs-lisp
     (add-hook 'example-mode-hook 'elisp-slime-nav-mode)
     (add-hook 'example-mode-hook 'eldoc-mode)
     (add-hook 'lisp-interaction-mode-hook 'eldoc-mode)
     (add-hook 'ielm-mode-hook 'eldoc-mode)
     (add-hook 'eval-expression-minibuffer-setup-hook 'eldoc-mode)
     (add-hook 'emacs-lisp-mode-hook 'easy-escape-minor-mode)

     (eval-after-load "easy-escape"
       (lambda ()
         (set-face-attribute 'easy-escape-face nil :foreground "red2")
         (set-face-attribute 'easy-escape-delimiter-face nil :foreground "red3")))
   #+END_SRC
** Haskell
   #+BEGIN_SRC emacs-lisp
     ;; (add-hook 'haskell-mode-hook 'intero-mode-whitelist)
     ;; (autoload 'intero-mode-whitelist "intero")
     ;; (setf intero-whitelist '("~/personal-workspace/learnopengl"))
     (setf haskell-indent-spaces 4)
     (setf haskell-stylish-on-save nil)
     (setf haskell-tags-on-save t)
     (setf haskell-process-suggest-remove-import-lines t)
     (setf haskell-process-auto-import-loaded-modules t)
     (setf haskell-process-suggest-hoogle-imports t)
     (setf haskell-process-use-presentation-mode t)
     (setf haskell-process-log t)
     (setf haskell-process-type 'cabal-new-repl)
     (setf haskell-process-args-cabal-new-repl '("--ghc-option=-ferror-spans" "--ghc-option=-fno-diagnostics-show-caret" "--ghc-option=-fshow-loaded-modules"))

     (defun binarin/haskell-mode-hook ()
       (company-mode t)
       (dante-mode t)
       (flycheck-mode t)
       (interactive-haskell-mode t)
       ;; (structured-haskell-mode t)
       (flyspell-prog-mode t)
       (set (make-local-variable 'company-backends)
            (append '((company-capf company-dabbrev-code company-yasnippet))
                    company-backends)))

     (eval-after-load "haskell"
       (lambda ()
         (define-key interactive-haskell-mode-map (kbd "C-c C-t") 'haskell-mode-show-type-at)
         (define-key interactive-haskell-mode-map (kbd "C-c C-l") 'haskell-process-load-or-reload)))

     (eval-after-load "haskell-mode"
       (lambda ()
         (define-key haskell-mode-map (kbd "C-c C-c") 'haskell-compile)
         (define-key haskell-mode-map (kbd "M-.") 'haskell-mode-jump-to-def-or-tag)))

     (eval-after-load "haskell-cabal"
       (lambda ()
         (define-key haskell-cabal-mode-map (kbd "C-c C-c") 'haskell-compile)))

     (add-hook 'haskell-mode-hook 'binarin/haskell-mode-hook)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (defun binarin/haskell-session-installed-modules (_session &optional _dontcreate)
       (let ((session (haskell-session-maybe))
             result)
         (when session
           (with-temp-buffer
             (call-process "ghc-pkg" nil t nil "dump" "--simple-output")
             (goto-char (point-min))
             (awhile (and (re-search-forward "exposed-modules:\n\\(\\( +.*\n\\)+\\)" nil t)
                          (goto-char (match-end 0)) ;; so nobody will mess with our match
                          (match-string 1))
               (setf result (nconc (split-string it) result)))))
         result))

     (defun binarin/haskell-session-installed-modules-advice (orig-fun &rest args)
       (apply #'binarin/haskell-session-installed-modules args))

     (advice-add 'haskell-session-installed-modules :around #'binarin/haskell-session-installed-modules-advice)

     (defun binarin/haskell-add-import (&optional scope qualified)
       (let ((modules-fn (if (eq scope :local)
                             #'haskell-session-project-modules
                           #'haskell-session-installed-modules)))
         (awhen (ivy-read "Module: " (funcall modules-fn (haskell-modules-session)))
           (goto-char (point-max))
           (haskell-navigate-imports)
           (when (eq scope :local) ;; try to choose the second group of imports
             (haskell-navigate-imports))
           (if (not qualified)
               (insert "import " it "\n")
             (let ((qualification (read-from-minibuffer "Qualifiy as: ")))
               (when qualification
                 (insert "import qualified " it " as " qualification "\n"))))
           (haskell-align-imports))))

     (defun binarin/haskell-add-global-import (prefix)
       (interactive "P")
       (binarin/haskell-add-import :global prefix))

     (defun binarin/haskell-add-local-import (prefix)
       (interactive "P")
       (binarin/haskell-add-import :local prefix))

     (eval-after-load "haskell-mode"
       (lambda ()
         (define-key haskell-mode-map (kbd "C-c i") #'binarin/haskell-add-global-import)
         (define-key haskell-mode-map (kbd "C-c l") #'binarin/haskell-add-local-import)))
   #+END_SRC
** Perl

   #+BEGIN_SRC emacs-lisp

     (defun binarin/system-to-string (command &rest args)
       "Execute command COMMAND with arguments ARGS and return its output as a string."
       (with-output-to-string
         (with-current-buffer
           standard-output
           (apply #'process-file command nil t nil args))))

     (defun binarin/all-perl-modules ()
       (let ((perl-code "
     use File::Find::Rule;

     sub modulize {
       for ($_[0]) {
         s/\.pm$//;
         s|/|::|g;
       }
       $_;
     }

     $SIG{__WARN__} = sub { }; # some silly warning from File::Find::Rule about our silliness =)

     my @files = map {modulize $_} File::Find::Rule->extras({follow => 1})->relative->file()->name( q{*.pm} )->in( @INC );

     say for sort @files;

     "))
         (s-lines (binarin/system-to-string "booking-perl" "-E" perl-code))))

     (defun binarin/insert-perl-import (module)
       (end-of-line)
         (insert "\n")
         (beginning-of-line)
         (insert "use " module ";"))

     (defun binarin/choose-perl-import ()
       (interactive "")
       (ivy-read "Module name: " (binarin/all-perl-modules) :action #'binarin/insert-perl-import))

   #+END_SRC

** Python
   #+BEGIN_SRC emacs-lisp
     (defun binarin/python-mode-hook ()
       (setf whitespace-style '(tabs trailing tab-mark face lines-tail))
       (whitespace-mode 1))

     (add-hook 'python-mode-hook #'binarin/python-mode-hook)
   #+END_SRC
** HTML
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode))
     (eval-after-load "web-mode"
       (lambda ()
         (setf web-mode-enable-engine-detection t)
         (add-to-list 'web-mode-engines-alist '("go" . "\\.html\\'"))))

     (defun binarin/less-css-mode-hook ()
       (firestarter-mode)
       (setf firestarter
             '(projectile-with-default-dir (projectile-project-root)
                (let ((display-buffer-alist '(("^*Async Shell Command*" . (display-buffer-no-window)))))
                  (async-shell-command "make"))
                )))

     (add-hook 'less-css-mode-hook #'binarin/less-css-mode-hook)

   #+END_SRC
* Keybindings
** Other keybindings
   :PROPERTIES:
   :ID:       fe486346-9be0-4866-b0bc-155030c7bea5
   :END:
   #+BEGIN_SRC emacs-lisp
     (general-define-key "M-SPC" 'cycle-spacing)
   #+END_SRC

  #+begin_src emacs-lisp
    (global-set-key (kbd "M-&") 'delete-other-windows)
    ;; (global-set-key (kbd "M-[") 'split-window-below) -- fucks up bracketed-paste in terminal
    (global-set-key (kbd "M-{") 'split-window-right)
    (define-key org-mode-map (kbd "M-{") 'split-window-right)

    ;;(global-set-key (kbd "M-o") 'other-window)
    ;;(global-set-key (kbd "M-o") 'next-multiframe-window)
    (defun binarin/other-window-multiframe ()
      (interactive)
      (other-window 1 'visible)
      (select-frame-set-input-focus (selected-frame)))
    (global-set-key (kbd "M-o") #'binarin/other-window-multiframe)
    (global-set-key (kbd "M-n") 'delete-window)
  #+end_src

  #+begin_src emacs-lisp
    (global-set-key "\e\eb" (lambda () (interactive) (switch-to-buffer (other-buffer))))
    (global-set-key "\e\ec" 'comment-region)
    (global-set-key "\e\ei" 'indent-region)
    (global-set-key "\e\el" 'goto-line)
    (global-set-key "\e\et" 'toggle-truncate-lines)
    (global-set-key [f2]  'save-buffer)
  #+end_src
