#+TITLE: binarin's emacs configuration
#+OPTIONS: toc:4 h:4
* File header
  :PROPERTIES:
  :ID:       872629ce-4d48-47d4-b276-f7935cd31243
  :END:
** Enable lexical bindings
  #+begin_src emacs-lisp
    ;; -*- lexical-binding: t -*-
  #+end_src

** Load helper modules
  #+begin_src emacs-lisp
    (package-initialize)

    (require 'cl-lib)
    (require 'f)
    (require 's)
    (require 'dash)
    (require 'anaphora)
    (require 'hydra)
    (require 'general)

    ;; general-setq will also call triggers on customizable setttings,
    ;; allowing them to be properly changed even after corresponding
    ;; package was loaded
    (fset 'gsetq 'general-setq)
  #+end_src

** Use separate lisp file for customizations made through UI
   Load it early, so any lisp customizations can override customized values.
  #+begin_src emacs-lisp
    (gsetq custom-file (concat (file-name-directory binarin/primary-emacs-config) "custom.el"))
    (load-file custom-file)
  #+end_src

* Startup
** Hide startup screen

   #+begin_src emacs-lisp
       (gsetq inhibit-startup-screen t)
   #+end_src

** Delay keybindings

   I want my keybindings to be applied late in the initialization
   process, after all keymaps are already created and packages are
   loaded.

   #+BEGIN_SRC emacs-lisp
     (defvar binarin/keybindings nil)
     (defvar binarin/keybindings-applied nil)

     (defun binarin/define-key (&rest args)
       (when binarin/keybindings-applied
	 (apply #'general-define-key args))
       (add-to-list 'binarin/keybindings args))

     (defun binarin/apply-queued-keybindings ()
       (setf binarin/keybindings-applied t)
       (-each binarin/keybindings #'(lambda (args) (apply #'general-define-key args))))
   #+END_SRC

* Appearance
** Fonts
   :PROPERTIES:
   :ID:       26d38fee-8252-4024-b0e8-1466ff4052c9
   :END:

  #+begin_src emacs-lisp
    (gsetq default-frame-alist '((font . "Iosevka-22")))
    (defconst binarin/minimal-screen-width 124
      "Iosevka-22 on 1920x1080 screen")
  #+end_src

** Theme
   #+begin_src emacs-lisp
     (require 'zenburn-theme)
   #+end_src
** Set window title
   Full name in window title, will be shown in taskbar.

   #+begin_src emacs-lisp
       (gsetq frame-title-format
             '((:eval (if (buffer-file-name)
                          (abbreviate-file-name (buffer-file-name))
                        "%b"))
               " - "
               invocation-name))
   #+end_src

** Remove visual clutter
   :PROPERTIES:
   :ID:       8ee1f692-db6b-4fac-bb48-edb5910c779b
   :END:

   #+begin_src emacs-lisp
     (awhen (window-system)
       (toggle-scroll-bar -1)
       (tool-bar-mode -1))
   #+end_src

** Tool-tips
   #+BEGIN_SRC emacs-lisp
     (gsetq x-gtk-use-system-tooltips nil)
   #+END_SRC
** smart-mode-line
   #+begin_src emacs-lisp
     (require 'smart-mode-line)
     (require 'smart-mode-line-powerline-theme)

     (setf sml/theme 'powerline)
     (setf rm-blacklist '(" hl-p" " Smrt" " Paredit" " Helm" " SliNav" " yas" " MRev" " ARev" " ElDoc" " Undo-Tree" " ^_^" " FS" " Fly" " EditorConfig" " wb" " ez-esc"))
     (sml/setup)
     ;; sml loves to reset this faces completely, so lets enforce our settings after initializing sml
     (set-face-attribute 'mode-line nil :height 0.6)
     (set-face-attribute 'mode-line-inactive nil :height 0.6)
   #+end_src

** Line and column numbers
   #+begin_src emacs-lisp
     (line-number-mode t)
     (column-number-mode t)
   #+end_src

* Behavior
** Helm
   :PROPERTIES:
   :ID:       8a6ae7ca-1e23-4820-b260-4ece0d844335
   :END:

   #+begin_src emacs-lisp
     (require 'helm-mode)
     (global-unset-key (kbd "C-x c"))

     ;; (require 'helm-org)
     (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to run persistent action
     (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
     (define-key helm-map (kbd "M-x")  'helm-select-action) ; list actions using C-z

     (when (executable-find "curl")
       (gsetq helm-google-suggest-use-curl-p t))

     (gsetq helm-quick-update                     t ; do not display invisible candidates
	   helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
	   helm-buffers-fuzzy-matching           t ; fuzzy matching buffer names when non--nil
	   helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
	   helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
	   helm-ff-file-name-history-use-recentf t)

     (global-set-key (kbd "M-x") 'helm-M-x)
     (global-set-key (kbd "M-y") 'helm-show-kill-ring)
     (global-set-key (kbd "C-x C-f") 'helm-find-files)
     (global-set-key [f3] 'helm-find-files)

     (helm-mode 1)
   #+end_src

** Ivy
   #+BEGIN_SRC emacs-lisp
     (require 'ivy)

     (binarin/define-key "C-'" 'swiper)

     (binarin/define-key
      :keymaps 'ivy-mode-map
      "C-'" 'ivy-avy)

     (ivy-mode 1)

     ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
     (gsetq ivy-use-virtual-buffers t)
     (gsetq ivy-virtual-abbreviate 'full)

     ;; number of result lines to display
     (gsetq ivy-height 10)

     ;; does not count candidates
     (gsetq ivy-count-format "")

     ;; no regexp by default
     (gsetq ivy-initial-inputs-alist nil)

     ;; configure regexp engine.
     (gsetq ivy-re-builders-alist
	    ;; allow input not in order
	    '((t   . ivy--regex-ignore-order)))
   #+END_SRC
** History
    :PROPERTIES:
    :ID:       9dea8cec-794d-4757-84de-2c166ce10567
    :END:
    #+begin_src emacs-lisp
      (gsetq savehist-additional-variables '(search-ring kill-ring regexp-search-ring)
	     savehist-autosave-interval 60 ;; from default 300
	     history-length t
	     history-delete-duplicates t)
      (savehist-mode t)
    #+end_src

    #+begin_src emacs-lisp
      (gsetq recentf-max-saved-items 2000
	     kill-ring-max 5000
	     undo-limit (* 20 1024 1024)
	     undo-strong-limit (* 40 1024 1024)
	     undo-outer-limit (* 100 1024 1024)
	     mark-ring-max 5000
	     global-mark-ring-max 5000)
    #+end_src

    #+begin_src emacs-lisp
      (save-place-mode t)
    #+end_src

** Dired
   #+BEGIN_SRC emacs-lisp
     (add-hook 'dired-mode-hook 'dired-hide-details-mode)
     (binarin/define-key "C-x C-j" 'dired-jump)
     (gsetq dired-dwim-target t)
     (gsetq dired-listing-switches "-al --group-directories-first")
     (eval-after-load "dired"
       #'(lambda () (require 'dired-x)))
   #+END_SRC
** Truncate lines by default
   #+begin_src emacs-lisp
     (gsetq truncate-lines t)
   #+end_src

** Paredit
   :PROPERTIES:
   :ID:       13fbc9ee-bd2c-441b-8b36-ab2d8e153aa7
   :END:

   #+begin_src emacs-lisp
     (add-hook 'emacs-lisp-mode-hook       (lambda () (paredit-mode +1)))
     (add-hook 'example-mode-hook          (lambda () (paredit-mode +1)))
     (add-hook 'lisp-mode-hook             (lambda () (paredit-mode +1)))
     (add-hook 'scheme-mode-hook           (lambda () (paredit-mode +1)))
     (add-hook 'lisp-interaction-mode-hook (lambda () (paredit-mode +1)))
     (add-hook 'slime-repl-mode-hook       (lambda () (paredit-mode +1)))
   #+end_src

** Projectile
   :PROPERTIES:
   :ID:       a86040e5-291f-4b62-ab76-f6b213a483c8
   :END:
   #+begin_src emacs-lisp
     (require 'projectile)
     (gsetq projectile-mode-line nil
            projectile-enable-caching t)

     (projectile-global-mode)

     (add-to-list 'projectile-project-root-files ".edts")
     (add-to-list 'projectile-project-root-files "erlang.mk")
   #+end_src
** Keybindings
   #+BEGIN_SRC emacs-lisp
     (binarin/define-key
      "<f4>" 'replace-string
      "C-<f4>" 'replace-regexp
      "<f12>" 'magit-status
      "C-<f3>" 'binarin/kill-current-buffer)

     (defun binarin/kill-current-buffer ()
       (interactive)
       (kill-buffer (current-buffer)))
   #+END_SRC
** Capture
   :PROPERTIES:
   :ID:       4bc78dad-e5f5-40ba-8d98-c57f4261c7a7
   :END:
   #+begin_src emacs-lisp
     (setq org-default-notes-file "~/org/refile.org")
     (define-key global-map "\C-cr" 'org-capture)

     (defun binarin/hide-drawers-hook ()
       (save-excursion
	 (beginning-of-buffer)
	 (org-cycle-hide-drawers 'children)))

     (defun binarin/capture-remove-guidance-comment ()
       (save-excursion
	 (beginning-of-buffer)
	 (delete-matching-lines "^ \*# J:")))

     (add-hook 'org-capture-mode-hook #'binarin/hide-drawers-hook)
     (add-hook 'org-capture-mode-hook #'auto-fill-mode)
     (add-hook 'org-capture-prepare-finalize-hook #'binarin/capture-remove-guidance-comment)

     (setq org-capture-templates
	   '(("t" "todo" entry
	      (file "~/org/refile.org")
	      "* TODO %?\n  :PROPERTIES:\n  :ID: %(org-id-new)\n  :END:\n  %u\n  %a" :prepend t :kill-buffer nil)
	     ("j" "journal" entry
	      (file+olp+datetree "~/org/journal.org")
	      (file "~/.rc/org-journal-template.org")
	      :tree-type week)
	     ("n" "comment on clocked" plain
	      (clock)
	      "%?")
	     ("c" "contact" entry
	      (file "~/org/refile.org")
	      (file "~/.rc/org-contact-template.org"))
	     ("w" "org-protocol" entry
	      "* TODO %c\n\n  :PROPERTIES:\n  :ID: %(org-id-new)\n  :END:  %U" :prepend t :immediate-finish t :kill-buffer nil)
	     ("l" "Link" entry
	      (file "~/org/refile.org")
	      "* TODO %a\n  :PROPERTIES:\n  :ID: %(org-id-new)\n  :END:\n  %U\n\n  %i" :prepend t :immediate-finish t :kill-buffer nil)))

     (defvar binarin/org-protocol-mundane-link-descriptions
       '(" - binarin@gmail.com - Gmail"
	 " - Booking.com Ltd"
	 " - YouTube"
	 " - Booking.com Mail"))

     (defun binarin/org-protocol-capture-postprocess ()
       (awhen (re-search-forward (concat (regexp-opt binarin/org-protocol-mundane-link-descriptions t) "]]") nil t)
	 (replace-match "]]")))

     (add-hook 'org-capture-prepare-finalize-hook #'binarin/org-protocol-capture-postprocess)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (require 'org-protocol)
     (autoload 'notifications-notify "notifications")

     (defun binarin/display-notify-after-capture (&rest args)
       (notifications-notify
        :title "Link captured"
        :body (cadar org-stored-links)
        :app-name "emacs"
        :app-icon (expand-file-name "~/.rc/org.svg")
        :timeout 3000
        :urgency 'low))

     (advice-add 'org-protocol-do-capture :after #'binarin/display-notify-after-capture)
   #+END_SRC
** server
  #+begin_src emacs-lisp
    (defun binarin/server-start ()
      (require 'server)
      (unless (server-running-p server-name)
        (server-start)))

    (add-hook 'after-init-hook #'binarin/server-start)

    (setf server-temp-file-regexp "^/tmp/\\(zsh\\|Re\\)\\|/draft$")
  #+end_src

** Browser choice
   #+BEGIN_SRC emacs-lisp
     (gsetq browse-url-browser-function #'browse-url-xdg-open)
   #+END_SRC
** Change "yes or no" to "y or n"
   :PROPERTIES:
   :ID:       28aa80f7-9512-43ac-ba91-c45510d86f2c
   :END:

   #+begin_src emacs-lisp
     (fset 'yes-or-no-p 'y-or-n-p)
   #+end_src


** Whitespace handling
*** Tabs and spaces
    #+BEGIN_SRC emacs-lisp
      (setf indent-tabs-mode nil)
      (setf tab-width 8)
      (setq-default indent-tabs-mode nil)
    #+END_SRC
*** ws-butler
    Trims trailing whitespace, but only on lines that were edited.
    #+begin_src emacs-lisp
      (add-hook 'prog-mode-hook 'ws-butler-mode)
      (add-hook 'text-mode-hook 'ws-butler-mode)
    #+end_src

** Ctrl-Z map
   #+BEGIN_SRC emacs-lisp
     (defvar ctrl-z-map (make-sparse-keymap))

     (binarin/define-key
      "C-z" ctrl-z-map)

     (binarin/define-key
      :keymaps 'ctrl-z-map
      "C-z" 'suspend-frame
      "C-g" 'keyboard-quit)
   #+END_SRC
** Prevent accidental exit
   Prompt on C-x C-c - no more accidential exits
   #+begin_src emacs-lisp
     (setf confirm-kill-emacs #'y-or-n-p)
   #+end_src
** Copy/paste
   #+BEGIN_SRC emacs-lisp
     (setf select-enable-primary t)
     (setf select-enable-clipboard t)
     (setf save-interprogram-paste-before-kill t)
     (setf x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
   #+END_SRC
** I18n
*** Russian layout over Programmers Dvorak
    :PROPERTIES:
    :ID:       b04b5557-e261-4073-ac6b-93e62e587ed6
    :END:

    #+begin_src emacs-lisp
      ;; -*- coding: iso-2022-7bit-unix -*-
      (quail-define-package
       "russian-computer-d" "Russian" "RU" nil
       "ЙЦУКЕН Russian computer layout over Programmers Dvorak"
       nil t t t t nil nil nil nil nil t)

      ;;  №% "7 ?5 /3 (1 =9 *0 )2 +4 -6 !8 ;:
      ;;   Й  Ц  У  К  Е  Н  Г  Ш  Щ  З  Х  Ъ
      ;;    Ф  Ы  В  А  П  Р  О  Л  Д  Ж  Э
      ;;     Я  Ч  С  М  И  Т  Ь  Б  Ю  .,

      (quail-define-rules
       ("&" ?№)
       ("[" ?\")
       ("{" ??)
       ("}" ?/)
       ("(" ?()
       ("=" ?=)
       ("*" ?*)
       (")" ?))
       ("+" ?+)
       ("]" ?-)
       ("!" ?!)
       ("#" ?\;)
       ("%" ?%)
       ("7" ?7)
       ("5" ?5)
       ("3" ?3)
       ("1" ?1)
       ("9" ?9)
       ("0" ?0)
       ("2" ?2)
       ("4" ?4)
       ("6" ?6)
       ("8" ?8)
       ("`" ?:)

       ("$" ?ё)
       (";" ?й)
       ("," ?ц)
       ("." ?у)
       ("p" ?к)
       ("y" ?е)
       ("f" ?н)
       ("g" ?г)
       ("c" ?ш)
       ("r" ?щ)
       ("l" ?з)
       ("/" ?х)
       ("@" ?ъ)
       ("a" ?ф)
       ("o" ?ы)
       ("e" ?в)
       ("u" ?а)
       ("i" ?п)
       ("d" ?р)
       ("h" ?о)
       ("t" ?л)
       ("n" ?д)
       ("s" ?ж)
       ("-" ?э)
       ("\\" ?\\)
       ("'" ?я)
       ("q" ?ч)
       ("j" ?с)
       ("k" ?м)
       ("x" ?и)
       ("b" ?т)
       ("m" ?ь)
       ("w" ?б)
       ("v" ?ю)
       ("z" ?.)
       ("~" ?Ё)
       (":" ?Й)
       ("<" ?Ц)
       (">" ?У)
       ("P" ?К)
       ("Y" ?Е)
       ("F" ?Н)
       ("G" ?Г)
       ("C" ?Ш)
       ("R" ?Щ)
       ("L" ?З)
       ("?" ?Х)
       ("^" ?Ъ)
       ("A" ?Ф)
       ("O" ?Ы)
       ("E" ?В)
       ("U" ?А)
       ("I" ?П)
       ("D" ?Р)
       ("H" ?О)
       ("T" ?Л)
       ("N" ?Д)
       ("S" ?Ж)
       ("_" ?Э)
       ("|" ?|)
       ("\"" ?Я)
       ("Q" ?Ч)
       ("J" ?С)
       ("K" ?М)
       ("X" ?И)
       ("B" ?Т)
       ("M" ?Ь)
       ("W" ?Б)
       ("V" ?Ю)
       ("Z" ?,))
    #+end_src

*** Prefer Russian and UTF-8
#+begin_src emacs-lisp
  (set-language-environment "Russian")
  (setq default-input-method "russian-computer-d")
  (prefer-coding-system 'utf-8-unix)
#+end_src
** Autosaving

   Save backups to one place and don't clutter filesystem with files ending in ~.
   #+begin_src emacs-lisp
     (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
   #+end_src

   As Sacha Chua put it, "Disk space is cheap. Save lots".
   #+begin_src emacs-lisp
     (setq delete-old-versions -1)
     (setq version-control t)
     (setq vc-make-backup-files t)
     (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
   #+end_src

** File locking

   I don't care about preventing simultaneous edits, it still will be
   detected when saving is made. But disabling it prevents our working
   dirs from being clobbered with lock-files.
   #+begin_src emacs-lisp
     (setf create-lockfiles nil)
   #+end_src

** Automatically make scripts executable
   #+BEGIN_SRC emacs-lisp
     (add-hook 'after-save-hook
               'executable-make-buffer-file-executable-if-script-p)
   #+END_SRC
** Window handling
   #+BEGIN_SRC emacs-lisp
     (winner-mode 1)
   #+END_SRC
** Improved help buffers
   #+BEGIN_SRC emacs-lisp
     (autoload 'helpful-function "helpful")
     (global-set-key (kbd "C-h f") #'helpful-function)
   #+END_SRC

** Version control
   #+BEGIN_SRC emacs-lisp
     (setf vc-follow-symlinks t)
   #+END_SRC
** undo-tree
   #+begin_src emacs-lisp
     (require 'undo-tree)
     (add-hook 'after-init-hook 'global-undo-tree-mode)

     (binarin/define-key
      (general-chord "jk") 'undo-tree-undo
      (general-chord "kj") 'undo-tree-undo
      (general-chord "wm") 'undo-tree-redo
      (general-chord "mw") 'undo-tree-redo)
   #+end_src

** Key chords
#+begin_src emacs-lisp
  (require 'key-chord)
  (key-chord-mode t)
#+end_src

* Org
** Agenda files
   Expand filenames so we can later directly compare them with (buffer-file-name)

   #+begin_src emacs-lisp
     (gsetq org-agenda-files
           (-map #'f-expand
                 (-filter #'f-exists?
                          '("~/org/personal.org"
                            "~/org/contacts.org"
                            "~/org/blog.org"
                            "~/org/refile.org"
                            "~/org/booking.org"
                            "~/org/bcal.org"
                            "~/org/bcal-spd.org"
                            "~/org/bcal-evts.org"
                            "~/.rc/emacs-config.org"
                            "~/org/ference.org"))))
   #+end_src

** Task classification
   #+BEGIN_SRC emacs-lisp
     (defun bh/is-task-p ()
       "Any task with a todo keyword and no subtask"
       (save-restriction
         (widen)
         (let ((has-subtask)
               (subtree-end (save-excursion (org-end-of-subtree t)))
               (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
           (save-excursion
             (forward-line 1)
             (while (and (not has-subtask)
                         (< (point) subtree-end)
                         (re-search-forward "^\*+ " subtree-end t))
               (when (member (org-get-todo-state) org-todo-keywords-1)
                 (setq has-subtask t))))
           (and is-a-task (not has-subtask)))))

     (defun bh/is-project-p ()
       "Any task with a todo keyword subtask"
       (save-restriction
         (widen)
         (let ((has-subtask)
               (subtree-end (save-excursion (org-end-of-subtree t)))
               (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
           (save-excursion
             (forward-line 1)
             (while (and (not has-subtask)
                         (< (point) subtree-end)
                         (re-search-forward "^\*+ " subtree-end t))
               (when (member (org-get-todo-state) org-todo-keywords-1)
                 (setq has-subtask t))))
           (and is-a-task has-subtask))))
   #+END_SRC

** Todo states
   #+begin_src emacs-lisp
     (gsetq org-enforce-todo-dependencies t)

     (gsetq org-use-fast-todo-selection 'prefix)
     (gsetq org-fast-tag-selection-single-key t)

     (gsetq org-todo-keywords
	   '((sequence "TODO(t)" "NEXT(s)" "|" "DONE(d!)")
	     (type "|" "CANCELLED(c)")
	     (type "HOLD(h)" "WAIT(w)" "|")))

     (gsetq org-todo-keyword-faces
	   '(("TODO" :foreground "red" :weight bold)
	     ("NEXT" :foreground "cyan3" :weight bold)
	     ("DONE" :foreground "green4" :weight bold)

	     ("WAIT" :foreground "orange3" :weight bold)
	     ("HOLD" :foreground "orange3" :weight bold)
	     ("CANCELLED" :foreground "forest green" :weight bold)))

     (defun bh/clock-in-to-next (kw)
       "Switch a task from TODO to NEXT when clocking in.
     Skips capture tasks, projects, and subprojects.
     Switch projects and subprojects from NEXT back to TODO"
       (when (not (and (boundp 'org-capture-mode) org-capture-mode))
	 (cond
	  ((and (member (org-get-todo-state) (list "TODO"))
		(bh/is-task-p))
	   "NEXT")
	  ((and (member (org-get-todo-state) (list "NEXT"))
		(bh/is-project-p))
	   "TODO"))))

     (gsetq org-clock-in-switch-to-state #'bh/clock-in-to-next)
   #+end_src

** Contexts
   #+begin_src emacs-lisp
     (setq context-tags
           '(("HOME" . ?h)  ;; home
             ("WORK" . ?w)  ;; office
             ("CITY" . ?y)  ;; on the go
             ("COMP" . ?c)  ;; some place that has trusted computer
             ("PHON" . ?o)  ;; anywhere where I can make phone call
             ))

     (setq context-tag-includes
           '(("HOME" "COMP" "PHON")
             ("WORK" "COMP" "PHON")
             ("CITY" "PHON")
             ("COMP")))

     (setq org-tag-alist `((:startgroup . nil) ;; contexts
                           ,@context-tags
                           (:endgroup . nil)
                           ("AGND" . ?a)
                           ("PROJ" . ?p)
                           ("NEXT" . ?n)
                           ("HABT" . ?b)))
   #+end_src

** Appearance
   #+begin_src emacs-lisp
     (gsetq org-pretty-entities nil)
     (gsetq org-agenda-dim-blocked-tasks t)
     (gsetq org-ellipsis " ▾")
     (gsetq org-cycle-separator-lines 0)
   #+end_src

   #+begin_src emacs-lisp
     (gsetq org-tags-column (- (length org-ellipsis) binarin/minimal-screen-width)
	   org-agenda-tags-column (- (length org-ellipsis) binarin/minimal-screen-width))
   #+end_src

   #+begin_src emacs-lisp
     (eval-after-load "org-habit"
       (lambda ()
	 (gsetq org-habit-graph-column (- binarin/minimal-screen-width
					  org-habit-preceding-days
					  org-habit-following-days
					  1))))
   #+end_src

** Behaviour
   #+begin_src emacs-lisp
     (gsetq org-reverse-note-order t)
     (gsetq org-outline-path-complete-in-steps nil)
     (gsetq org-catch-invisible-edits 'smart)
     (gsetq org-return-follows-link t)
     (gsetq org-id-link-to-org-use-id t)
     (gsetq org-fast-tag-selection-include-todo nil)
     (gsetq org-use-speed-commands t)
   #+end_src
** Agenda
   #+begin_src emacs-lisp
     (binarin/define-key "C-c a" 'org-agenda)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (gsetq org-agenda-include-diary nil
	    org-agenda-span 'day
	    org-agenda-start-on-weekday 1
	    org-agenda-window-setup 'current-window

	    org-agenda-hide-tags-regexp "ATTACH"

	    org-agenda-todo-ignore-with-date t
	    org-agenda-skip-deadline-if-done t
	    org-agenda-skip-scheduled-if-done t
	    org-agenda-skip-timestamp-if-done t

	    org-deadline-warning-days 30
	    org-agenda-window-frame-fractions '(1 . 1)
	    org-agenda-restore-windows-after-quit t

	    org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2 :narrow 60)
	    org-clock-report-include-clocking-task 't

	    org-agenda-block-separator nil)
   #+END_SRC


   #+begin_src emacs-lisp
     (defun binarin/agenda-sorter-tag-first (tag)
       #'(lambda (a b)
	   (let ((ta (member (downcase tag) (get-text-property 1 'tags a)))
		 (tb (member (downcase tag) (get-text-property 1 'tags b))))
	     (cond
	      ((and ta tb) nil)
	      ((not ta) -1)
	      (t +1)))))

     (defvar binarin/org-include-scheduled-todos
       '((org-agenda-todo-ignore-scheduled nil)
	 (org-agenda-todo-ignore-deadlines nil)
	 (org-agenda-todo-ignore-with-date nil))
       "Items with scheduling information are usually hidden from
     agendas, but sometimes we want to include everything. This list
     will spliced into org-agenda-custom-commands on such occasions.
     ")

     (defvar binarin/project-matcher
       "+PROJ/+TODO")

     (defun binarin/todo-filter-for-context (context)
       "Generates tags-todo filter string for a given context"
       (concat (mapconcat 'identity
			  (list* "-agenda_hide"
				 (cl-remove-if (lambda (elt)
						 (member elt (or (assoc context context-tag-includes)
								 context)))
					       (mapcar 'car context-tags)))
			  "-")
	       "/+NEXT"))

     (gsetq org-agenda-sorting-strategy '((agenda habit-down time-up priority-down category-keep)
					  (todo priority-down user-defined-down category-keep)
					  (tags priority-down category-keep)
					  (search category-keep))
	    org-agenda-cmp-user-defined (binarin/agenda-sorter-tag-first "NEXT"))

     (defun binarin/shrink-text ()
       (text-scale-increase 0)
       (text-scale-increase -1))

     (add-hook 'org-agenda-mode-hook #'binarin/shrink-text)

     (defconst binarin/agenda-block-separator
       "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━")

     (defun binarin/context-based-agendas ()
       (loop for (tag . char) in context-tags
	     collect (list (concat "l" (char-to-string char))
			   (concat "Agenda and context " tag)
			   `((agenda "" ((org-agenda-span 2)))
			     (tags-todo ,(binarin/todo-filter-for-context tag)
					((org-agenda-overriding-header ,(concat binarin/agenda-block-separator "\nContext: " tag))
					 (org-agenda-todo-ignore-scheduled t)
					 (org-agenda-todo-ignore-deadlines t)
					 (org-agenda-sorting-strategy '(priority-down user-defined-down category-up))
					 (org-agenda-cmp-user-defined ',(binarin/agenda-sorter-tag-first tag))))
			     (tags-todo ,binarin/project-matcher
					((org-agenda-overriding-header ,(concat binarin/agenda-block-separator "\nProjects: "))
					 (org-agenda-dim-blocked-tasks t))))
			   `((org-agenda-dim-blocked-tasks 'invisible)))))

     (setq org-agenda-custom-commands
	   `(("r" "Refile New Notes and Tasks" tags "LEVEL=1+REFILE" ,binarin/org-include-scheduled-todos)
	     ("l" . "Context-based agenda")
	     ,@(binarin/context-based-agendas)))

     (setq org-agenda-tags-todo-honor-ignore-options t)
   #+end_src
** Contacts
   #+BEGIN_SRC emacs-lisp
     (require 'org-contacts)
     (gsetq org-contacts-files '("~/org/contacts.org"))

     (defconst binarin/org-contact-field-defaults
       '(("TYPE" . "person")
         ("EMAIL" . "")
         ("PHONE" . "")
         ("BIRTHDAY" . "")
         ("GENDER" . "")))

     (defun binarin/helm-org-contacts-field-insert (field)
       (awhen (assoc field binarin/org-contact-field-defaults)
         (org-set-property field (cdr it))
         (org-back-to-heading)
         (let ((range (org-get-property-block (point) 'force)))
           (org-flag-drawer nil)
           (goto-char (car range))
           (re-search-forward (org-re-property field nil t)))))

     (gsetq helm-source-org-contacts-field
       `((name . "Org-contacts fields")
         (candidates . ,(-map #'car binarin/org-contact-field-defaults))
         (no-matchplugin)
         (nohighlight)
         (action . binarin/helm-org-contacts-field-insert)))

     (defun helm-org-contacts-field ()
       "Select a field for insertion in an org-contacts entry."
       (interactive)
       (helm :sources '(helm-source-org-contacts-field)))
   #+END_SRC
** Refiling
   #+BEGIN_SRC emacs-lisp
     ;; Targets include this file and any file contributing to the agenda - up to 5 levels deep
     (gsetq org-refile-targets
           '((org-agenda-files :maxlevel . 5)
             (nil :maxlevel . 5)))

     ;; Targets start with the file name - allows creating level 1 tasks
     (gsetq org-refile-use-outline-path 'file)

     (defun binarin/update-parent-todo-statistics (&rest rest)
       (save-excursion
         (org-update-parent-todo-statistics)))

     (add-hook 'org-after-refile-insert-hook #'binarin/update-parent-todo-statistics)

     (advice-add 'org-refile :after #'binarin/update-parent-todo-statistics)

     (advice-add 'org-archive-subtree :after #'binarin/update-parent-todo-statistics)
   #+END_SRC

** Persistence
   Synchronization is performed by external process, so try to be in
   sync with disk.
   #+BEGIN_SRC emacs-lisp
     (run-at-time nil 60 'org-save-all-org-buffers)
     (add-hook 'org-mode-hook (lambda () (auto-revert-mode 1)))
   #+END_SRC
** Habits
   #+BEGIN_SRC emacs-lisp
     (require 'org-habit)
   #+END_SRC
** Clocking
   :PROPERTIES:
   :ID:       677d1432-15de-42c8-8a43-f39549acde65
   :END:
   #+begin_src emacs-lisp
     ;; Yes it's long... but more is better ;)

     (set-face-attribute 'org-mode-line-clock nil :background "black")
     (set-face-attribute 'org-mode-line-clock-overrun nil :background "red")

     (setf org-clock-history-length 35)

     ;; Resume clocking task on clock-in if the clock is open
     (setf org-clock-in-resume t)

     ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
     (setf org-clock-out-remove-zero-time-clocks t)

     ;; Don't clock out when moving task to a done state
     (setf org-clock-out-when-done nil)

     ;; Save the running clock and all clock history when exiting Emacs, load it on startup
     (setf org-clock-persist t)

     ;; Keep clocks running
     (setq org-log-into-drawer t)

     (org-clock-persistence-insinuate)

     (setq org-time-stamp-rounding-minutes (quote (1 15)))

     (setq org-columns-default-format "%85ITEM(Task) %8Effort(Effort){:} %8CLOCKSUM")
     (setq org-global-properties (quote (("Effort_ALL" . "0:10 0:30 1:00 2:00 3:00 4:00 5:00 6:00 7:00 8:00"))))

     (require 'org-clock)
     (add-hook 'emacs-startup-hook #'org-clock-load)

     (defun binarin/clockout-nagger ()
       (call-process "desktop-nagger" nil nil nil))

     (defun binarin/clockout-remove-nagger ()
       (call-process "pkill" nil nil nil "-f" "desktop-nagger"))

     (add-hook 'org-clock-out-hook #'binarin/clockout-nagger)
     (add-hook 'org-clock-in-hook #'binarin/clockout-remove-nagger)
   #+end_src

   I want to automatically clock-out from a current task if a computer
   was inactive for some time. Builtin org-mode supports asking what I
   want to do with such task, but I want to just clock-out
   unconditionally - it makes moving between computers
   easier.

   #+begin_src emacs-lisp
     (setf org-clock-x11idle-program-name "xprintidle-ng")
     (setf org-x11idle-exists-p t)

     ;; (SEC-HIGH SEC-LOW MICROSEC PICOSEC) current-idle-time
     (defvar binarin/idle-clockout-timeout 1800
       "Perform first attempt to clock-out after this period of emacs
       inactivity. It can decide to postpone the clocking-out if it's
       only emacs that is idle, but not the computer itself.")

     (defvar binarin/idle-clockout-recheck-interval 300
       "After a sufficient idle time was achieved by emacs, we'll
       periodically check current idle time of the whole OS to decide
       whether we need to clock out")

     (defvar binarin/idle-clockout-repeat-timer nil
       "Timer for repeatedly (during a single idle interval) checking
       whether we need to clock-out")

     (defun binarin/clockout-when-idle ()
       (awhen binarin/idle-clockout-repeat-timer
         (cancel-timer it))
       (when (org-clocking-p)
         (if (> (org-user-idle-seconds)
                binarin/idle-clockout-timeout)
             (org-clock-out nil t)
           (setf binarin/idle-clockout-repeat-timer
                 (run-with-idle-timer
                  (time-add (current-idle-time) binarin/idle-clockout-recheck-interval)
                  nil
                  'binarin/clockout-when-idle)))))

     (run-with-idle-timer binarin/idle-clockout-timeout t 'binarin/clockout-when-idle)
   #+end_src

   #+BEGIN_SRC emacs-lisp
     (defconst binarin/common-tasks-for-clocking
       '(("internet" . "3762fad1-cf8c-40ae-b010-bacc1cf6b879")
	 ("daily" . "c7e6c3e1-41a2-4fdc-84ee-d56ca3c8b8e3")
	 ("weekly" . "6ddefbe6-9130-4707-94f3-2bc4da826bea")))

     (defun binarin/clock-in-predefined (alias)
       (aand (assoc alias binarin/common-tasks-for-clocking)
	     (org-id-find (cdr it) t)
	     (save-current-buffer
	       (save-excursion
		 (set-buffer (marker-buffer it))
		 (goto-char (marker-position it))
		 (let ((org-clock-in-switch-to-state nil))
		   (org-clock-in))))))

     (defhydra binarin/org-clock-hydra (:exit t)
       "org-mode clocking"
       ("<f11>" org-clock-goto "goto current")
       ("i" org-clock-in "clock in")
       ("o" org-clock-out "clock out")
       ("O" (lambda ()
	      (interactive)
	      (binarin/clockout-remove-nagger)
	      (org-clock-out)
	      (binarin/clockout-remove-nagger))
	"clock out no nagger")
       ("n" (binarin/clock-in-predefined "internet") "Тупление в интернете")
       ("d" (binarin/clock-in-predefined "daily") "Daily review")
       ("w" (binarin/clock-in-predefined "weekly") "Weekly review"))

     (binarin/define-key "<f11>" 'binarin/org-clock-hydra/body)
   #+END_SRC
** Drawers
   #+BEGIN_SRC emacs-lisp
     (setq org-drawers '("PROPERTIES" "LOGBOOK" "CLOCK" "FILES"))
     (setq org-clock-into-drawer "CLOCK")
     (setq org-export-with-drawers t)
   #+END_SRC

** Notifications
   #+BEGIN_SRC emacs-lisp

     (require 'appt)

     (defun binarin/refresh-appts ()
       (org-agenda-to-appt t))

     ;; Run once, activate and schedule refresh
     (binarin/refresh-appts)
     (appt-activate t)
     (run-at-time "24:01" nil #'binarin/refresh-appts)

     ; Update appt each time agenda opened.
     (add-hook 'org-finalize-agenda-hook #'binarin/refresh-appts)

     (defvar binarin/last-appt-notify-id nil)

     (defun binarin/appt-notify (min-to-app new-time msg)
       (setf binarin/last-appt-notify-id
             (notifications-notify
              :title "Appointment"
              :body (if (listp msg) (string-join msg "\\n") msg)
              :timeout 5000
              :urgency 'normal)))


     ; Setup zenify, we tell appt to use window, and replace default function
     (setf appt-display-format 'window)
     (setf appt-disp-window-function #'binarin/appt-notify)
     (setf appt-message-warning-time 10)


   #+END_SRC

** Templates
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'org-structure-template-alist '("l"  "#+BEGIN_SRC emacs-lisp\n\n#+END_SRC" "<src lang=\"emacs-lisp\">\n\n</src>"))
   #+END_SRC
* Programming
** Perl
    #+begin_src emacs-lisp
      (fset 'perl-mode 'cperl-mode)

      (gsetq cperl-auto-newline t
	     cperl-hairy t
	     cperl-brace-offset 0   
	     cperl-close-paren-offset -4  
	     cperl-continued-brace-offset 0   
	     cperl-continued-statement-offset 4   
	     cperl-extra-newline-before-brace nil 
	     cperl-extra-newline-before-brace-multiline nil 
	     cperl-indent-level 4   
	     cperl-indent-parens-as-block t   
	     cperl-label-offset -4  
	     cperl-merge-trailing-else nil 
	     cperl-tab-always-indent t)

      (add-to-list 'auto-mode-alist '("\\.t$" . perl-mode))

      (defun binarin/cperl-mode-hook ()
	(origami-mode t)
	(hs-minor-mode t)
	(yas-minor-mode t)
	(setf prettify-symbols-alist '(("->" . ?→)
				       (">=" . ?≥)
				       ("<=" . ?≤)
				       ("<>" . ?≠)
				       ("=>" . ?⇒)))
  
	(prettify-symbols-mode t)
	(local-set-key (read-kbd-macro "C-c C-c") 'origami-forward-toggle-node)
	(local-set-key (read-kbd-macro "M-.") 'helm-etags-select)
	(setf tags-file-name (expand-file-name "TAGS" (projectile-project-root))
	      tags-table-list nil))

      (add-hook 'cperl-mode-hook 'binarin/cperl-mode-hook)
   #+end_src

* File footer
** Apply delayed keybindings
   #+BEGIN_SRC emacs-lisp
     (binarin/apply-queued-keybindings)
   #+END_SRC
